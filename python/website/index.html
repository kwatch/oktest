<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.7: http://docutils.sourceforge.net/" />
<title>Oktest - a new style testing library -</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="oktest-readme">
<h1 class="title">Oktest - a new style testing library -</h1>

<p>Release: 0.11.0</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id1">Overview</a></li>
<li><a class="reference internal" href="#download" id="id2">Download</a></li>
<li><a class="reference internal" href="#example" id="id3">Example</a></li>
<li><a class="reference internal" href="#assertion-reference" id="id4">Assertion Reference</a></li>
<li><a class="reference internal" href="#test-decorator" id="id5">&#64;test Decorator</a></li>
<li><a class="reference internal" href="#fixture-injection" id="id6">Fixture Injection</a></li>
<li><a class="reference internal" href="#test-context" id="id7">Test Context</a></li>
<li><a class="reference internal" href="#unified-diff" id="id8">Unified Diff</a></li>
<li><a class="reference internal" href="#tracer" id="id9">Tracer</a></li>
<li><a class="reference internal" href="#skip-test" id="id10">Skip Test</a></li>
<li><a class="reference internal" href="#todo-decorator" id="id11">&#64;todo decorator</a></li>
<li><a class="reference internal" href="#command-line-interface" id="id12">Command-line Interface</a></li>
<li><a class="reference internal" href="#helpers-reference" id="id13">Helpers Reference</a><ul>
<li><a class="reference internal" href="#oktest-module" id="id14"><tt class="docutils literal">oktest</tt> module</a></li>
<li><a class="reference internal" href="#oktest-util-module" id="id15"><tt class="docutils literal">oktest.util</tt> module</a></li>
<li><a class="reference internal" href="#oktest-dummy-module" id="id16"><tt class="docutils literal">oktest.dummy</tt> module</a></li>
<li><a class="reference internal" href="#oktest-tracer-module" id="id17"><tt class="docutils literal">oktest.tracer</tt> module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tips" id="id18">Tips</a></li>
<li><a class="reference internal" href="#license" id="id19">License</a></li>
<li><a class="reference internal" href="#copyright" id="id20">Copyright</a></li>
</ul>
</div>
<div class="section" id="overview">

<h2><a class="toc-backref" href="#id1">Overview</a></h2>
<p>Oktest is a new-style testing library for Python.</p>
<pre class="literal-block">
from oktest import test, ok, NG

class FooTest(unittest.TestCase):

   &#64;test(&quot;1 + 1 should be 2&quot;)
   def _(self):
      ok (1+1) == 2          # same as assertEqual(2, 1+1)

   &#64;test(&quot;other examples&quot;)
   def _(self):
      ok (s) == 'foo'        # same as assertEqual(s, 'foo')
      ok (s) != 'foo'        # same as assertNotEqual(s, 'foo')
      ok (n) &gt; 0             # same as assertTrue(n &gt; 0)
      ok (fn).raises(Error)  # same as assertRaises(Error, fn)
      ok ([]).is_a(list)     # same as assertTrue(isinstance([], list))
      NG ([]).is_a(tuple)    # same as assertTrue(not isinstance([], tuple))
      ok ('A.txt').is_file() # same as assertTrue(os.path.isfile('A.txt'))
      NG ('A.txt').is_dir()  # same as assertTrue(not os.path.isdir('A.txt'))
</pre>
<p>Features:</p>
<ul class="simple">
<li>Provides <tt class="docutils literal">ok()</tt> which is much shorter than <tt class="docutils literal">self.assertXxxx()</tt>.</li>
<li>Allow to write test name in free text.</li>
<li><a class="reference internal" href="#fixture-injection">Fixture Injection</a> support.</li>
<li><a class="reference internal" href="#tracer">Tracer</a> class is provided which can be used as mock or stub.</li>
<li>Text diff (diff -u) is displayed when texts are different.</li>
</ul>
<p>Oktest requires Python 2.4 or later (3.x is supported).</p>
<p>See <a href="CHANGES.txt">CHANGES.txt</a> for changes.</p>
</div>
<div class="section" id="download">

<h2><a class="toc-backref" href="#id2">Download</a></h2>
<p><a class="reference external" href="http://pypi.python.org/pypi/Oktest/">http://pypi.python.org/pypi/Oktest/</a></p>
<p>Installation:</p>
<pre class="literal-block">
## if you have installed easy_install:
$ sudo easy_install Oktest
## or download Oktest-0.11.0.tar.gz and install it
$ wget http://pypi.python.org/packages/source/O/Oktest/Oktest-0.11.0.tar.gz
$ tar xzf Oktest-0.11.0.tar.gz
$ cd Oktest-0.11.0/
$ sudo python setup.py install
</pre>
</div>
<div class="section" id="example">

<h2><a class="toc-backref" href="#id3">Example</a></h2>
<p>Oktest is available with unittest module which is a standard testing library
of Python.</p>
<pre class="literal-block">
import unittest
<strong>from oktest ok</strong>

class FooTest(unittest.TestCase):

    def test_1_plus_1_should_be_2(self):
        <strong>ok (1+1) == 2</strong>    # instead of self.assertEqual(2, 1+1)

    def test_string_should_contain_digits(self):
        <strong>ok (&quot;foo 123 bar&quot;).matches(r&quot;\d+&quot;)</strong>

if __name__ == '__main__':
    unittest.main()
</pre>
<p>See <a class="reference internal" href="#assertion-reference">Assertion Reference</a> section for details about ok() and NG().</p>
<p>Using &#64;test decorator, you can write test name in free text.</p>
<pre class="literal-block">
import unittest
from oktest ok, <strong>test</strong>

class FooTest(unittest.TestCase):

    <strong>&#64;test(&quot;1 + 1 should be 2&quot;)</strong>
    <strong>def _(self):</strong>
        ok (1+1) == 2

    <strong>&#64;test(&quot;string should contain digits&quot;)</strong>
    <strong>def _(self):</strong>
        ok (&quot;foo 123 bar&quot;).matches(r&quot;\d+&quot;)

if __name__ == '__main__':
    unittest.main()
</pre>
<p>See <a class="reference internal" href="#test-decorator">&#64;test Decorator</a> section for details about &#64;test decorator.</p>
<p>Oktest is also available without unittest. See the folloing example.</p>
<pre class="literal-block">
import sys, os
<strong>import oktest</strong>
from oktest import ok, NG, test

## no need to extend TestCase class
class Example1Test(object):

    ## invoked only once before all tests
    &#64;classmethod
    <strong>def before_all(cls):</strong>  # or setUpClass(cls)
        os.mkdir('tmp.d')

    ## invoked only once after all tests done
    &#64;classmethod
    <strong>def after_all(cls):</strong>  # or tearDownClass(cls)
        import shutil
        shutil.rmtree('tmp.d')

    ## invoked before each test
    <strong>def before(self):</strong>   # or setUp(self)
        self.val = ['aaa', 'bbb', 'ccc']

    ## invoked after each test
    <strong>def after(self):</strong>    # or tearDown(self)
        pass

    ## test methods

    &#64;test(&quot;value should be a list&quot;)
    def _(self):
        ok (self.val).is_a(list)

    &#64;test(&quot;list length should be 3&quot;)
    def _(self):
        ok (len(self.val)) == 3

## invoke tests
if __name__ == '__main__':
    <strong>oktest.main()</strong>
    ## or
    #<strong>oktest.run(r'.*Test$')</strong>
    ## or
    #<strong>oktest.run(Example1Test, Example2Test)</strong>
</pre>
<p>Both <tt class="docutils literal">Oktest.main()</tt> and <tt class="docutils literal">Oktest.run()</tt> accept unittest.TestCase and other class.</p>
</div>
<div class="section" id="assertion-reference">

<h2><a class="toc-backref" href="#id4">Assertion Reference</a></h2>
<dl class="docutils">
<dt>ok (x) == y</dt>
<dd>Raise AssertionError unless x == y.</dd>
<dt>ok (x) != y</dt>
<dd>Raise AssertionError unless x != y.</dd>
<dt>ok (x) &gt; y</dt>
<dd>Raise AssertionError unless x &gt; y.</dd>
<dt>ok (x) &gt;= y</dt>
<dd>Raise AssertionError unless x &gt;= y.</dd>
<dt>ok (x) &lt; y</dt>
<dd>Raise AssertionError unless x &lt; y.</dd>
<dt>ok (x) &lt;= y</dt>
<dd>Raise AssertionError unless x &lt;= y.</dd>
<dt>ok (x).in_delta(y, delta)</dt>
<dd>Raise AssertionError unless y-delta &lt; x &lt; y+delta.</dd>
<dt>ok (x).in_(y)</dt>
<dd>Raise AssertionError unless x in y.</dd>
<dt>ok (x).not_in(y)</dt>
<dd>Raise AssertionError if x in y.</dd>
<dt>ok (x).contains(y)</dt>
<dd>Raise AssertionError unless y in x. This is opposite of in_().</dd>
<dt>ok (x).is_(y)</dt>
<dd>Raise AssertionError unless x is y.</dd>
<dt>ok (x).is_not(y)</dt>
<dd>Raise AssertionError if x is y.</dd>
<dt>ok (x).is_a(y)</dt>
<dd>Raise AssertionError unless isinstance(x, y).</dd>
<dt>ok (x).is_not_a(y)</dt>
<dd>Raise AssertionError if isinstance(x, y).</dd>
<dt>ok (x).has_attr(name)</dt>
<dd>Raise AssertionError unless hasattr(x, name).</dd>
<dt>ok (x).attr(name, value)</dt>
<dd>Raise AssertionError unless hasattr(x, name) and getattr(x, name) == value.</dd>
<dt>ok (x).matches(y[, flag=0])</dt>
<dd>If y is a string, raise AssertionError unless re.search(y, x).
If y is a re.pattern object, raise AssertionError unless y.search(x).
You can pass flag such as <tt class="docutils literal">re.M | re.S</tt>.</dd>
<dt>ok (x).not_match(y[, flag=0])</dt>
<dd>If y is a string, raise AssertionError if re.search(y, x).
If y is a re.pattern object, raise AssertionError if y.search(x).
You can pass flag such as <tt class="docutils literal">re.M | re.S</tt>.</dd>
<dt>ok (x).length(n):</dt>
<dd>Raise AssertionError unless len(x) == n.
This is same as <tt class="docutils literal">ok (len(x)) == n</tt>, but it is useful to chain
assertions, like <tt class="docutils literal">ok <span class="pre">(x).is_a(tuple).length(n)</span></tt>.</dd>
<dt>ok (path).is_file()</dt>
<dd>Raise AssertionError unless os.path.isfile(path).</dd>
<dt>ok (path).not_file()</dt>
<dd>Raise AssertionError if os.path.isfile(path).</dd>
<dt>ok (path).is_dir()</dt>
<dd>Raise AssertionError unless os.path.isdir(path).</dd>
<dt>ok (path).not_dir()</dt>
<dd>Raise AssertionError if os.path.isdir(path).</dd>
<dt>ok (path).exists()</dt>
<dd>Raise AssertionError unless os.path.exists(path).</dd>
<dt>ok (path).not_exist()</dt>
<dd>Raise AssertionError if os.path.exists(path).</dd>
<dt>ok (func).raises(error_class[, errmsg=None])</dt>
<dd><p class="first">Raise AssertionError unless func() raises error_class.
Second argument is a string or regular expression (re.compile() object).
It sets raised exception into 'func.exception' therefore you can do another test with raised exception object.</p>
<pre class="last literal-block">
obj = &quot;foobar&quot;
def f():
    obj.name
ok (f).raises(AttributeError, &quot;'str' object has no attribute 'name'&quot;)
ok (f.exception.message) == &quot;'str' object has no attribute 'name'&quot;
</pre>
</dd>
<dt>ok (func).not_raise([error_class=Exception])</dt>
<dd>Raise AssertionError if func() raises error_class.</dd>
<dt>ok (value).should</dt>
<dd>Special property to test boolean method.
For example, <tt class="docutils literal">ok <span class="pre">(string).should.startswith('foo')</span></tt> is same as
to <tt class="docutils literal">ok <span class="pre">(string.startswith('foo'))</span> == True</tt>.</dd>
<dt>ok (value).should_not</dt>
<dd>Special property to test boolean method.
For example, <tt class="docutils literal">ok <span class="pre">(string).should_not.startswith('foo')</span></tt> is same as
to <tt class="docutils literal">ok <span class="pre">(string.startswith('foo'))</span> == False</tt>.</dd>
<dt>NG (x)</dt>
<dd><p class="first">Opposite of ok(x). For example, 'NG (&quot;foo&quot;).matches(r&quot;[0-9]+&quot;)' is True.</p>
<pre class="last literal-block">
fname = 'file.txt'
open(fname, 'w').write('foo')
ok (fname).is_file()            # file exists
os.unlink(fname)
NG (fname).is_file()        # file doesn't exist
</pre>
</dd>
<dt>not_ok (x)</dt>
<dd>Same as NG(x). Provided for backward compatibility.</dd>
<dt>NOT (x)</dt>
<dd>Same as NG(x). Provided experimentalily.</dd>
<dt>fail(message)</dt>
<dd>Raises AssertionError with message.</dd>
</dl>
<p>It is possible to chain assertions.</p>
<pre class="literal-block">
## chain assertion methods
ok (func()).is_a(tuple).length(2)
d = datetime.date(2000, 12, 31)
ok (d).attr('year', 2000).attr('month', 12).attr('day', 31)
</pre>
<p>Oktest allows you to define custom assertion functions.
See <a class="reference internal" href="#tips">Tips</a> section.</p>
</div>
<div class="section" id="test-decorator">

<h2><a class="toc-backref" href="#id5">&#64;test Decorator</a></h2>
<p>Oktest provides &#64;test decorator.
It is simple but very powerful.</p>
<p>Using &#64;test decorator, you can write test description in free text instead of
test method:</p>
<pre class="literal-block">
import unittest
<strong>from oktest import test</strong>

class FooTest(unittest.TestCase):

    def test_1_plus_1_should_be_2(self):  # not cool...
        assert 1+1 == 2

    <strong>&#64;test(&quot;1 + 1 should be 2&quot;)</strong>    # cool! easy to read &amp; write!
    <strong>def _(self):</strong>
        assert 1+1 == 2
</pre>
<p>&#64;test decorator changes test methods.
For example, the above code is same as the following:</p>
<pre class="literal-block">
class FooTest(unittest.TestCase):
    __n = 0

    def _(self):
        assert 1+1 == 2

    __n += 1
    _.__doc__  = &quot;1 + 1 should be 2&quot;
    _.__name__ = &quot;test_%03d: %s&quot; % (__n, _.__doc__)
    locals()[_.__name__] = _
</pre>
<p>Non-English language is available on &#64;test():</p>
<pre class="literal-block">
class FooTest(unittest.TestCase):

    <strong>&#64;test(&quot;1 + 1 は 2 になること。&quot;)</strong>
    def _(self):
        assert 1+1 == 2
</pre>
<p>&#64;test decorator accepts user-defined options. You can specify any name and
value as option. It is accessable by 'self._options' in setUp(), therefore
you can change behaviour of setUp() according to options.</p>
<pre class="literal-block">
class FooTest(unittest.TestCase):

    def setUp(self):
        tag = <strong>self._options.get(&quot;tag&quot;)</strong>
        if tag == &quot;experimental&quot;:
            ....

    &#64;test(&quot;1 + 1 should be 2&quot;, <strong>tag=&quot;experimental&quot;</strong>)
    def _(self):
        assert 1+1 == 2
</pre>
<p>You can filter testcase by user-defined options in command-line.</p>
<pre class="literal-block">
## do test only tagged as 'experimental'
$ python -m oktest.py <strong>-f tag=experimental</strong> test/*_test.py
</pre>
</div>
<div class="section" id="fixture-injection">

<h2><a class="toc-backref" href="#id6">Fixture Injection</a></h2>
<p>&#64;test decorator supports fixture injection.</p>
<ul class="simple">
<li>Arguments of test method are regarded as fixture names
and they are injected by &#64;test decorator automatically.</li>
<li>Instance methods or global functions which name is 'provide_xxxx' are
regarded as fixture provider (or builder) for fixture 'xxxx'.</li>
<li>Similar to that, instance methods or global functions which name is
'release_xxxx' are regarded as fixture releaser (or destroyer).
Notice that provider is mandatory but releaser is optional for fixture.</li>
</ul>
<pre class="literal-block">
class SosTest(unittest.TestCase):

    ##
    ## fixture providers
    ##
    def <strong>provide_member1</strong>(self):
        return {&quot;name&quot;: &quot;Haruhi&quot;}

    def <strong>provide_member2</strong>(self):
        return {&quot;name&quot;: &quot;Kyon&quot;}

    ##
    ## fixture releasers (optional)
    ##
    def <strong>release_member1</strong>(self, value):
        assert value == {&quot;name&quot;: &quot;Haruhi&quot;}

    ##
    ## testcase which requires 'member1' and 'member2' fixtures.
    ##
    &#64;test(&quot;validate member's names&quot;)
    def _(self, <strong>member1, member2</strong>):
        ok (member1[&quot;name&quot;]) == &quot;Haruhi&quot;
        ok (member2[&quot;name&quot;]) == &quot;Kyon&quot;
</pre>
<p>This feature is more flexible and useful than setUp() and tearDown().</p>
<p>For example, the following code ensures that dummy files are removed
automatically at the end of test without tearDown().</p>
<pre class="literal-block">
import os, shutil

def <strong>provide_cleaner()</strong>:
    paths = []
    return paths

def <strong>release_cleaner(paths)</strong>:
    assert isinstance(paths, list)
    ## remove dummy files registered
    for path in paths:
        if os.path.isfile(path):
            os.unlink(path)
        elif os.path.isdir(path):
            shutil.rmtree(path)

class FooTest(unittest.TestCase):

    &#64;test(&quot;example1&quot;)
    def _(self, <strong>cleaner</strong>):
        fpath = &quot;dummy.txt&quot;
        ## register dummy file
        <strong>cleaner.append(fpath)</strong>
        ## create dummy file and do test with it
        f = open(fpath, &quot;w&quot;); f.write(&quot;DUUUMY&quot;); f.close()
        ok (fpath).is_file()
</pre>
<p>Default parameter values of test methods are passed into provider functions
if necessary. Using this, you can change provider behaviour as you need.</p>
<pre class="literal-block">
## provider can have default value of argument
def provide_tempfile(<strong>content=&quot;dummy&quot;</strong>):
    filename = '__tmp.txt'
    with open(filename, 'w') as f:
        f.write(content)
    return filename

def release_tempfile(filename):
    if os.path.exists(filename):
        os.unlink(filename)

class FooTest(unittest.TestCase):

    ## override default value of providers by test method's
    ## default argument value
    &#64;test(&quot;example&quot;)
    def _(self, tempfile, <strong>content=&quot;AAAA&quot;</strong>):
        with open(tempfile) as f:
            s = f.read()
        ok (s) == <strong>&quot;AAAA&quot;</strong>

    ## if you don't specify default value in test method,
    ## provider's default value is used
    &#64;test(&quot;example&quot;)
    def _(self, tempfile):
        with open(tempfile) as f:
            s = f.read()
        ok (s) == <strong>&quot;dummy&quot;</strong>
</pre>
<p>Dependencies between fixtures are resolved automatically.
If you know dependency injection framework such as <a class="reference external" href="http://www.springsource.org/">Spring</a> or <a class="reference external" href="http://code.google.com/p/google-guice/">Guice</a>,
imagine to apply dependency injection into fixtures.</p>
<pre class="literal-block">
class BarTest(unittest.TestCase):

    ##
    ## for example:
    ## - Fixture 'a' depends on 'b' and 'c'.
    ## - Fixture 'c' depends on 'd'.
    ##
    def provide_<strong>a</strong>(<strong>b</strong>, <strong>c</strong>):  return b + c + [&quot;A&quot;]
    def provide_<strong>b</strong>():      return [&quot;B&quot;]
    def provide_<strong>c</strong>(<strong>d</strong>):     return d + [&quot;C&quot;]
    def provide_<strong>d</strong>():      reutrn [&quot;D&quot;]

    ##
    ## Dependencies between fixtures are solved automatically.
    ## If loop exists in dependency then &#64;test reports error.
    ##
    &#64;test(&quot;dependency test&quot;)
    def _(self, <strong>a</strong>):
        assert a == [&quot;B&quot;, &quot;D&quot;, &quot;C&quot;, &quot;A&quot;]
</pre>
<p>Fixture injection is provided by &#64;test decorator, and it is available
with existing test methods:</p>
<pre class="literal-block">
<strong>&#64;test()</strong>
def test_sample1(self, <strong>member1, member2</strong>):
    &quot;&quot;&quot;description&quot;&quot;&quot;
    ...
</pre>
<p>If you want to integrate with other fixture library, create manager object
and set it into <tt class="docutils literal">oktest.fixture_manager</tt>.
The following is an example to use <a class="reference external" href="https://github.com/mnoble/forge/">Forge</a> as external fixture library:</p>
<pre class="literal-block">
## fixture data
from forge import Forge
Forge.define('haruhi', name='Haruhi')
Forge.define('mikuru', name='Mikuru')
Forge.define('yuki',   name='Yuki')

## manager class
class ForgeFixtureManager(object):
    <strong>def provide(self, name):</strong>
        return Forge.build(name)
    <strong>def release(self, name, value):</strong>
        pass

## use it
<strong>oktest.fixture_manager =</strong> ForgeFixtureManager()
</pre>
</div>
<div class="section" id="test-context">

<h2><a class="toc-backref" href="#id7">Test Context</a></h2>
<p><strong>(Experimental)</strong></p>
<p>Oktest provides helper functions to describe test methods in structural style.</p>
<pre class="literal-block">
from oktest import ok, test
<strong>from oktest import subject, situation</strong>

class SampleTestCase(unittest.TestCase):
    <strong>SUBJECT = &quot;Sample&quot;</strong>

    <strong>with subject(&quot;method1()&quot;):</strong>

        <strong>with situation(&quot;when condition:&quot;):</strong>

            &#64;test(&quot;spec1&quot;)
            def _(self):
              ...

            &#64;test(&quot;spec2&quot;)
            def _(self):
              ...

        <strong>with situation(&quot;else:&quot;):</strong>

            &#64;test(&quot;spec3&quot;)
            def _(self):
                ...
</pre>
<p>Output example:</p>
<pre class="literal-block">
* Sample
  + method1()
    + when condition:
      - [passed] spec1
      - [passed] spec2
    + else:
      - [passed] spec3
## total:3, passed:3, failed:0, error:0, skipped:0, todo:0   (0.000 sec)
</pre>
<p>(Notice that this feature is experimental and may be changed in the future.)</p>
</div>
<div class="section" id="unified-diff">

<h2><a class="toc-backref" href="#id8">Unified Diff</a></h2>
<p>'ok(x) == y' prints unified diff (diff -u) if:</p>
<ul class="simple">
<li>both x and y are str or unicode</li>
<li>and x != y</li>
<li>and oktest.DIFF is True or 'repr'</li>
<li>and invoked with oktest.main() or oktest.run()</li>
</ul>
<p>For example:</p>
<pre class="literal-block">
## foo_test.py
import unittest
from oktest import ok

class FooTest(unittest.TestCase):

    def test1(self):
        s1 = ( &quot;AAA\n&quot;
               &quot;BBB\n&quot;
               &quot;CCC\n&quot; )
        s2 = ( &quot;AAA\n&quot;
               &quot;CCC\n&quot;
               &quot;DDD\n&quot; )
        ok (s1) == s2

if __name__ == '__main__':
    unittest.main()
</pre>
<p>If you run this script, you'll find that unified diff is displayed.</p>
<p>Output result:</p>
<pre class="literal-block">
$ python -V
Python 2.5.5
$ python foo_test.py
F
======================================================================
FAIL: test1 (__main__.FooTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;foo_test.py&quot;, line 14, in test1
    ok (s1) == s2
AssertionError: 'AAA\nBBB\nCCC\n' == 'AAA\nCCC\nDDD\n' : failed.
--- expected
+++ actual
&#64;&#64; -1,3 +1,3 &#64;&#64;
 AAA
+BBB
 CCC
-DDD


----------------------------------------------------------------------
Ran 1 test in 0.006s

FAILED (failures=1)
</pre>
<p>If you set <tt class="docutils literal">oktest.DIFF</tt> to <tt class="docutils literal">repr</tt>, each line is preprocessed by <tt class="docutils literal">repr()</tt>.
This is very useful to show non-visible characters. For example:</p>
<pre class="literal-block">
## foo_test.py
import unittest
from oktest import ok
import oktest
<strong>oktest.DIFF = repr</strong>

class FooTest(unittest.TestCase):

    def test1(self):
        s1 = ( &quot;AAA\n&quot;
               <strong>&quot;BBB  \n&quot;</strong>     # contains white space character
               &quot;CCC\n&quot; )
        s2 = ( &quot;AAA\n&quot;
               <strong>&quot;BBB\n&quot;</strong>
               &quot;CCC\n&quot; )
        ok (s1) == s2

if __name__ == '__main__':
    unittest.main()
</pre>
<p>Result:</p>
<pre class="literal-block">
$ python foo_test.py
F
======================================================================
FAIL: test1 (__main__.FooTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;foo_test.py&quot;, line 16, in test1
    ok (s1) == s2
AssertionError: 'AAA\nBBB \nCCC\n' == 'AAA\nBBB\nCCC\n' : failed.
--- expected
+++ actual
&#64;&#64; -1,3 +1,3 &#64;&#64;
 'AAA\n'
<strong>+'BBB  \n'</strong>
<strong>-'BBB\n'</strong>
 'CCC\n'


----------------------------------------------------------------------
Ran 1 test in 0.011s

FAILED (failures=1)
</pre>
<p>If you set '<tt class="docutils literal">oktest.DIFF</tt>' to False, unified diff is not displayed.</p>
</div>
<div class="section" id="tracer">

<h2><a class="toc-backref" href="#id9">Tracer</a></h2>
<p>Oktest provides <tt class="docutils literal">Tracer</tt> class which can be stub or mock object.
<tt class="docutils literal">Tracer</tt> class can:</p>
<ul class="simple">
<li>Create fake object.</li>
<li>Trace method or function call.</li>
<li>Fake method, or function.</li>
</ul>
<p>In any case, <tt class="docutils literal">Tracer</tt> object records both arguments and return-value of method or function calls.</p>
<p>Example to create fake object:</p>
<pre class="literal-block">
## create fake objects
<strong>from oktest.tracer import Tracer</strong>
<strong>tr = Tracer()</strong>
foo = <strong>tr.fake_obj(m1=100, m2=200)</strong>   # method name and return-value
bar = <strong>tr.fake_obj(m3=lambda self, x: x+1)</strong>  # method name and body
## call fake methods
ok (bar.m3(0))     == 1
ok (foo.m2(1,2,3)) == 200    # any argument can be passed
ok (foo.m1(x=123)) == 100    # any argument can be passed
## check results
ok (repr(<strong>tr[0]</strong>))   == 'm3(0) #=&gt; 1'
ok (repr(<strong>tr[1]</strong>))   == 'm2(1, 2, 3) #=&gt; 200'
ok (repr(<strong>tr[2]</strong>))   == 'm1(x=123) #=&gt; 100'
</pre>
<p>There are several ways to check results:</p>
<pre class="literal-block">
from oktest.tracer import Tracer
tr = Tracer()
obj = tr.fake_obj(meth=9)
ok (obj.meth(1, 2, x=3)) == 9
## check results
ok (<strong>repr(tr[0])</strong>)  == 'meth(1, 2, x=3) #=&gt; 9'
## or
ok (<strong>tr[0].list()</strong>) == [obj, 'meth', (1, 2), {'x': 3}, 9]
## or
ok (<strong>tr[0]</strong>)        == [obj, 'meth', (1, 2), {'x': 3}, 9]
## or
ok (<strong>tr[0].receiver</strong>).is_(obj)
ok (<strong>tr[0].name</strong>)   == 'meth'
ok (<strong>tr[0].args</strong>)   == (1, 2)
ok (<strong>tr[0].kwargs</strong>) == {'x': 3}
ok (<strong>tr[0].ret</strong>)    == 9
</pre>
<p>Example to trace method call:</p>
<pre class="literal-block">
class Foo(object):
    def add(self, x, y):
        return x + y
    def hello(self, name='World'):
        return &quot;Hello &quot; + name
obj = Foo()
## trace methods
from oktest.tracer import Tracer
tr = Tracer()
<strong>tr.trace_method(obj, 'add', 'hello')</strong>
## call methods
ok (obj.add(2, 3)) == 5
ok (obj.hello(name=&quot;SOS&quot;)) == &quot;Hello SOS&quot;
## check results
ok (tr[0]) == [obj, 'add', (2, 3), {}, 5]
ok (tr[1]) == [obj, 'hello', (), {'name':'SOS'}, &quot;Hello SOS&quot;]
</pre>
<p>Example to trace function call:</p>
<pre class="literal-block">
def f(x):
    return x+1
def g(y):
    return f(y+1) + 1
## trace functions
from oktest.tracer import Tracer
tr = Tracer()
<strong>f = tr.trace_func(f)</strong>
<strong>g = tr.trace_func(g)</strong>
## call functions
ok (g(0)) == 3
## check results
ok (tr[0]) == [None, 'g', (0,), {}, 3]
ok (tr[1]) == [None, 'f', (1,), {}, 2]
</pre>
<p>Example to fake method call:</p>
<pre class="literal-block">
class Foo(object):
    def add(self, x, y):
        return x + y
    def hello(self, name='World'):
        return &quot;Hello &quot; + name
obj = Foo()
## fake methods
from oktest.tracer import Tracer
tr = Tracer()
def dummy(original_func, *args, **kwargs):
    return &quot;Hello!&quot;
<strong>tr.fake_method(obj, add=100, hello=dummy)</strong>
## call methods
ok (obj.add(2, 3)) == 100
ok (obj.hello(name=&quot;SOS&quot;)) == &quot;Hello!&quot;
## check results
ok (tr[0]) == [obj, 'add', (2, 3), {}, 100]
ok (tr[1]) == [obj, 'hello', (), {'name':&quot;SOS&quot;}, &quot;Hello!&quot;]
</pre>
<p>Example to fake function call:</p>
<pre class="literal-block">
def f(x):
    return x*2
## fake a function
def dummy(original_func, x):
    return 'x=%s' % repr(x)
from oktest.tracer import Tracer
tr = Tracer()
<strong>f = tr.fake_func(f, dummy)</strong>
## call function
ok (f(3))  == 'x=3'
## check results
ok (tr[0]) == [None, 'f', (3,), {}, 'x=3']
</pre>
</div>
<div class="section" id="skip-test">

<h2><a class="toc-backref" href="#id10">Skip Test</a></h2>
<p><strong>(Experimental)</strong></p>
<p>It is possible to skip tests according to a certain condition.</p>
<pre class="literal-block">
import unittest
import oktest
from oktest import ok, test, <strong>skip</strong>
some_condition = True

class SkipExampleTest(unittest.TestCase):

    &#64;test(&quot;example of skip&quot;)
    def _(self):
        if some_condition:
            <strong>skip(&quot;reason to skip&quot;)</strong>
        ...

    &#64;test(&quot;example of skip&quot;)
    <strong>&#64;skip.when(some_condition, &quot;reason to skip&quot;)</strong>
    def _(self):
        ...

    ## unittest2 helpers are also available (if you installed it)
    &#64;unittest.skipIf(some_condition, &quot;reason to skip&quot;)
    def testExample(self):
        ...

if __name__ == '__main__':
    oktest.main()
</pre>
<p>Notice that the following doesn't work correctly.</p>
<pre class="literal-block">
## NG: &#64;skip.when should be the below of &#64;test
&#64;skip.when(some_condition, &quot;reason to skip&quot;)
&#64;test(&quot;example of skip&quot;)
def _(self):
    ...
</pre>
</div>
<div class="section" id="todo-decorator">

<h2><a class="toc-backref" href="#id11">&#64;todo decorator</a></h2>
<p>&#64;todo decorator represents that &quot;this test will be failed expectedly
because feature is not implemented yet, therefore don't count
this test as failed, please!&quot;.</p>
<p>Code Example:</p>
<pre class="literal-block">
import unittest
from oktest import ok, test, <strong>todo</strong>

def add(x, y):
    return 0    ## not implemented yet!

class AddTest(unittest.TestCase):
    SUBJECT = 'add()'

    &#64;test(&quot;returns sum of arguments.&quot;)
    <strong>&#64;todo</strong>      # equivarent to &#64;unittest.expectedFailure
    def _(self):
        n = add(10, 20)
        ok (n) == 30    # will be failed expectedly
                        # (because add() is not implemented yet)

if __name__ == '__main__':
    import oktest
    oktest.main()
</pre>
<p>Output Example:</p>
<pre class="literal-block">
$ python test/add_test.py
* add()
  - [TODO] returns sum of arguments.
## total:1, passed:0, failed:0, error:0, skipped:0, todo:1   (0.000 sec)
</pre>
<p>If test decoreated by &#64;todo doesn't raise AssertionError, Oktest will report
you that, for example:</p>
<pre class="literal-block">
$ python test/add_test.py
* add()
  - [Failed] returns sum of arguments.
----------------------------------------------------------------------
[Failed] add() &gt; 001: returns sum of arguments.
_UnexpectedSuccess: test should be failed (because not implemented yet), but passed unexpectedly.
----------------------------------------------------------------------
## total:1, passed:0, failed:1, error:0, skipped:0, todo:0   (0.000 sec)
</pre>
<p>Notice that the following will not work:</p>
<pre class="literal-block">
## NG: &#64;todo should be appeared after &#64;test decorator
&#64;todo
&#64;test(&quot;....&quot;)
def _(self): ...
</pre>
</div>
<div class="section" id="command-line-interface">

<h2><a class="toc-backref" href="#id12">Command-line Interface</a></h2>
<p>Oktest now supports command-line interface to execute test scripts.</p>
<pre class="literal-block">
## run test scripts except foo_*.py
$ python -m oktest <strong>-x 'foo_*.py' tests/*_test.py</strong>
## run test scripts in 'tests' dir with pattern '*_test.py'
$ python -m oktest <strong>-p '*_test.py' tests</strong>
## reports result in plain format (p: plain, s: simple, v: verbose)
$ python -m oktest <strong>-sp</strong> tests
## filter by class name
$ python -m oktest <strong>-f class='ClassName*'</strong> tests
## filter by test method name
$ python -m oktest <strong>-f test='*keyword*'</strong> tests   # or <strong>-f '*keyword*'</strong>
## filter by user-defined option added by &#64;test decorator
$ python -m oktest <strong>-f tag='*value*'</strong> tests
</pre>
<p>Try <tt class="docutils literal">python <span class="pre">-m</span> oktest <span class="pre">-h</span></tt> for details about command-line options.</p>
<p>If you use <tt class="docutils literal">oktest.main()</tt> in your test script, it accepts command-line options.</p>
<pre class="literal-block">
## reports output in plain format
$ python test/foobar_test.py <strong>-sp -f test='*keyword*'</strong>
</pre>
</div>
<div class="section" id="helpers-reference">

<h2><a class="toc-backref" href="#id13">Helpers Reference</a></h2>
<div class="section" id="oktest-module">

<h3><a class="toc-backref" href="#id14"><tt class="docutils literal">oktest</tt> module</a></h3>
<dl class="docutils">
<dt>fail(message)</dt>
<dd>Raises AssertionError exception with message.</dd>
<dt>main(*args)</dt>
<dd><p class="first">Invokes tests of each class.
Args represents command-line options.</p>
<pre class="last literal-block">
import oktest
oktest.main()         # same as: python -m oktest
oktest.main('-sp')    # same as: python -m oktest -sp
</pre>
</dd>
<dt>NG(actual)</dt>
<dd>Represents test assertion.
See <a class="reference internal" href="#assertion-reference">Assertion Reference</a> section.</dd>
<dt>ok(actual)</dt>
<dd>Represents test assertion.
See <a class="reference internal" href="#assertion-reference">Assertion Reference</a> section.</dd>
<dt>run(*classes)</dt>
<dd><p class="first">Invokes tests of each class.
Argument can be regular expression string.</p>
<pre class="last literal-block">
import oktest
oktest.run(FooTest, BarTest)  # invokes FooTest and BarTest
oktest.run(r'.*Test$')        # invokes FooTest, BarTest, and so on
oktest.run()                  # same as oktest.run('.*(Test|TestCase|_TC)$')
</pre>
</dd>
<dt>subject(name)</dt>
<dd>Represents subject of specs such as ClassName, method_name() or feature name.
See <a class="reference internal" href="#test-context">Test Context</a> section.</dd>
<dt>situation(desc)</dt>
<dd>Represents situation of specs such as a certain condition.
See <a class="reference internal" href="#test-context">Test Context</a> section.</dd>
<dt>spec(description)</dt>
<dd><p class="first"><del>(Obsolete! Don't use this!)</del>
NOT OBSOLETED</p>
<p>Represents spec description.
This is just a marker function, but very useful for readability.</p>
<pre class="last literal-block">
class NumericTest(object):
    def test_integer(self):
        with spec(&quot;1+1 should be equal to 2.&quot;):
            ok (1+1) == 2
        with spec(&quot;1/0 should be error.&quot;):
            def f(): 1/0
            ok (f).raises(ZeroDivisionError,
                          &quot;integer division or modulo by zero&quot;)
        ## spec() is also available as decorator
        &#64;spec(&quot;1+1 should be equal to 2.&quot;)
        def _():
            ok (1+1) == 2
        ## tips: 'for' statement is available instead of 'with' for Python 2.4
        for _ in spec(&quot;1+1 should be equal to 2.&quot;):
            ok (1+1) == 2
</pre>
</dd>
<dt>skip(reason)</dt>
<dd>Skip test method.
Equivarent to <tt class="docutils literal">unittest.skip()</tt> or <tt class="docutils literal">unittest.skipIf()</tt>.
See <a class="reference internal" href="#skip-test">Skip Test</a> section.</dd>
<dt>test(desc)</dt>
<dd>Decorator to generate test method with spec description.
See <a class="reference internal" href="#test-decorator">&#64;test Decorator</a> section.</dd>
<dt>todo()</dt>
<dd>Represents that the test will be failed expectedly.
Equivarent to <tt class="docutils literal">unittest.expectedFailure()</tt>.
See <a class="reference internal" href="#todo-decorator">&#64;todo decorator</a> section.</dd>
</dl>
</div>
<div class="section" id="oktest-util-module">

<h3><a class="toc-backref" href="#id15"><tt class="docutils literal">oktest.util</tt> module</a></h3>
<p>Since 0.10.0, <tt class="docutils literal">oktest.helper</tt> is renamed to <tt class="docutils literal">oktest.util</tt>, but
<tt class="docutils literal">oktest.helper</tt> is still available for backward compatibility.</p>
<dl class="docutils">
<dt>chdir(dirname)</dt>
<dd><p class="first">Change current directory to dirname temporarily.</p>
<pre class="last literal-block">
import os
from oktest.util import chdir
cwd = os.getcwd()                         # current working directory
with chdir(&quot;/var/tmp&quot;):
    assert os.getcwd() == &quot;/var/tmp&quot;      # current directory is changed!
    # do something
assert os.getcwd() == cwd                 # back to the original place
## or
&#64;chdir(&quot;/var/tmp&quot;)
def fn():
    assert os.getcwd() == &quot;/var/tmp&quot;
    # do something
</pre>
</dd>
<dt>rm_rf(filename, dirname, ...)</dt>
<dd>Remove file or directory recursively.</dd>
</dl>
</div>
<div class="section" id="oktest-dummy-module">

<h3><a class="toc-backref" href="#id16"><tt class="docutils literal">oktest.dummy</tt> module</a></h3>
<dl class="docutils">
<dt>dummy_file(filename, content)</dt>
<dd><p class="first">Create dummy file with specified content.</p>
<pre class="last literal-block">
import os
from oktest.helper import dummy_file
assert not os.path.exists(&quot;A.txt&quot;)        # file doesn't exist
with dummy_file(&quot;A.txt&quot;, &quot;aaa&quot;):
    assert os.path.isfile(&quot;A.txt&quot;)        # file is created!
    # do something
assert not os.path.exists(&quot;A.txt&quot;)        # file is removed
## or
&#64;dummy_file(&quot;A.txt&quot;, &quot;aaa&quot;)
def fn():
    assert os.path.isfile(&quot;A.txt&quot;)
</pre>
</dd>
<dt>dummy_dir(dirname)</dt>
<dd><p class="first">Create dummy directory.</p>
<pre class="last literal-block">
import os
from oktest.helper import dummy_dir
assert not os.path.exists(&quot;tmpdir&quot;)       # directory doesn't exist
with dummy_dir(&quot;tmpdir&quot;):
    assert os.path.isdir(&quot;tmpdir&quot;)        # directory is created!
    # do something
assert not os.path.exists(&quot;tmpdir&quot;)       # directory is removed
## or
&#64;dummy_dir(&quot;tmpdir&quot;)
def fn():
    assert os.path.isdir(&quot;tmpdir&quot;)
</pre>
</dd>
<dt>dummy_values(dictionary, items_=None, **kwargs):</dt>
<dd><p class="first">Change dictionary's values temporarily.</p>
<pre class="last literal-block">
from oktest.helper import dummy_values
d = {'A':10, 'B':20}
with dummy_values(d, A=1000, X=2000):
    assert d['A'] == 1000                 # dictionary values are changed!
    assert d['B'] == 20
    assert d['X'] == 2000
    # do something
assert d == {'A':10, 'B':20}              # values are backed
## or
&#64;dummy_values(d, A=1000, X=2000)
def fn():
    assert d['A'] == 1000
</pre>
</dd>
<dt>dummy_attrs(object, items_=None, **kwargs):</dt>
<dd><p class="first">Change object's attributes temporarily.
This is same as dummy_values(object.__dict__, **kwargs).</p>
<pre class="last literal-block">
from oktest.helper import dummy_attrs
class Hello(object):
    pass
obj = Hello()
obj.x = 10
obj.y = 20
with dummy_attrs(obj, x=90, z=100):
    assert obj.x == 90                    # attributes are changed!
    assert obj.y == 20
    assert obj.z == 100
    # do something
assert obj.x == 10                        # attributes are backed
assert obj.y == 20
assert not hasattr(obj, 'z')
## or
&#64;dummy_attrs(obj, x=90, z=100)
def fn():
    assert obj.x == 90
</pre>
</dd>
<dt>dummy_io(stdin_content=None, func=None):</dt>
<dd><p class="first">Set dummy I/O to sys.stdout, sys.stderr, and sys.stdin.</p>
<pre class="last literal-block">
with dummy_io(&quot;SOS&quot;) as d_io:
    assert sys.stdin.read() == &quot;SOS&quot;
    print(&quot;Haruhi&quot;)
sout, serr = d_io
assert sout == &quot;Haruhi\n&quot;
assert serr == &quot;&quot;
## or
&#64;dummy_io(&quot;SOS&quot;)
def d_io():
    assert sys.stdin.read() == &quot;SOS&quot;
    print(&quot;Haruhi&quot;)
sout, serr = d_io
assert sout == &quot;Haruhi\n&quot;
assert serr == &quot;&quot;
</pre>
</dd>
</dl>
</div>
<div class="section" id="oktest-tracer-module">

<h3><a class="toc-backref" href="#id17"><tt class="docutils literal">oktest.tracer</tt> module</a></h3>
<dl class="docutils">
<dt>Tracer:</dt>
<dd>Tracer class. See <a class="reference internal" href="#tracer">Tracer</a> section for details.</dd>
</dl>
</div>
</div>
<div class="section" id="tips">

<h2><a class="toc-backref" href="#id18">Tips</a></h2>
<ul>
<li><p class="first">You can define your own custom assertion function.</p>
<pre class="literal-block">
## define custom assertion function
import oktest
<strong>&#64;oktest.assertion</strong>
def startswith(self, arg):
    boolean = <strong>self.target</strong>.startswith(arg)
    if boolean == <strong>self.boolean</strong>:
        return True
    <strong>self.failed</strong>(&quot;%r.startswith(%r) : failed.&quot; % (self.target, arg))

## how to use
from oktest import ok
ok (&quot;Sasaki&quot;).startswith(&quot;Sas&quot;)
</pre>
</li>
<li><p class="first">It is possible to chain assertion methods.</p>
<pre class="literal-block">
## chain assertion methods
ok (func()).is_a(tuple).length(2)
d = datetime.date(2000, 12, 31)
ok (d).attr('year', 2000).attr('month', 12).attr('day', 31)
</pre>
</li>
<li><p class="first"><tt class="docutils literal">oktest.run()</tt> returns total number of failures and errors.</p>
<pre class="literal-block">
## exit with status code 0 when no errors.
sys.exit(run())
</pre>
</li>
<li><p class="first">If you call ok() or NG() but forget to do assertion, oktest warns it.</p>
<pre class="literal-block">
import oktest
from oktest import ok, NG

class FooTest(object):
    def test_1(self):
        #ok (1+1) == 2
        ok (1+1)         # missing assertion

oktest.run()   #=&gt; warning: ok() is called but not tested.
</pre>
</li>
<li><p class="first">$TEST environment variable is now obsolete.
Use command-line option instead to filter testcase by name.</p>
<pre class="literal-block">
## filter testcase by name
$ python -m oktest -f test='*foobar*' test/foo_test.py
</pre>
</li>
</ul>
</div>
<div class="section" id="license">

<h2><a class="toc-backref" href="#id19">License</a></h2>
<p>$License: MIT License $</p>
</div>
<div class="section" id="copyright">

<h2><a class="toc-backref" href="#id20">Copyright</a></h2>
<p>$Copyright: copyright(c) 2010-2014 kuwata-lab.com all rights reserved $</p>
</div>
</div>
</body>
</html>
