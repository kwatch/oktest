<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.9: http://docutils.sourceforge.net/" />
<title>Oktest - a new style testing library -</title>
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="oktest-readme">
<h1 class="title">Oktest - a new style testing library -</h1>

<p>Release: 0.15.0</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#overview" id="id1">Overview</a></li>
<li><a class="reference internal" href="#download" id="id2">Download</a></li>
<li><a class="reference internal" href="#example" id="id3">Example</a></li>
<li><a class="reference internal" href="#assertion-reference" id="id4">Assertion Reference</a></li>
<li><a class="reference internal" href="#custom-assertion" id="id5">Custom Assertion</a></li>
<li><a class="reference internal" href="#test-decorator" id="id6"><tt class="docutils literal">&#64;test</tt> Decorator</a></li>
<li><a class="reference internal" href="#fixture-injection" id="id7">Fixture Injection</a></li>
<li><a class="reference internal" href="#at-end-decorator" id="id8"><tt class="docutils literal">&#64;at_end</tt> Decorator</a></li>
<li><a class="reference internal" href="#test-context" id="id9">Test Context</a></li>
<li><a class="reference internal" href="#unified-diff" id="id10">Unified Diff</a></li>
<li><a class="reference internal" href="#testing-wsgi-application" id="id11">Testing WSGI Application</a></li>
<li><a class="reference internal" href="#validator" id="id12">Validator</a></li>
<li><a class="reference internal" href="#tracer" id="id13">Tracer</a></li>
<li><a class="reference internal" href="#skip-test" id="id14">Skip Test</a></li>
<li><a class="reference internal" href="#todo-decorator" id="id15"><tt class="docutils literal">&#64;todo</tt> Decorator</a></li>
<li><a class="reference internal" href="#command-line-interface" id="id16">Command-line Interface</a></li>
<li><a class="reference internal" href="#helpers-reference" id="id17">Helpers Reference</a><ul>
<li><a class="reference internal" href="#oktest-module" id="id18"><tt class="docutils literal">oktest</tt> module</a></li>
<li><a class="reference internal" href="#oktest-util-module" id="id19"><tt class="docutils literal">oktest.util</tt> module</a></li>
<li><a class="reference internal" href="#oktest-dummy-module" id="id20"><tt class="docutils literal">oktest.dummy</tt> module</a></li>
<li><a class="reference internal" href="#oktest-tracer-module" id="id21"><tt class="docutils literal">oktest.tracer</tt> module</a></li>
<li><a class="reference internal" href="#oktest-web-module" id="id22"><tt class="docutils literal">oktest.web</tt> module</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tips" id="id23">Tips</a></li>
<li><a class="reference internal" href="#license" id="id24">License</a></li>
<li><a class="reference internal" href="#copyright" id="id25">Copyright</a></li>
</ul>
</div>
<div class="section" id="overview">

<h2><a class="toc-backref" href="#id1">Overview</a></h2>
<p>Oktest is a new-style testing library for Python.</p>
<pre class="literal-block">
from oktest import test, ok, NG

class FooTest(unittest.TestCase):

   &#64;test(&quot;1 + 1 should be 2&quot;)
   def _(self):
      ok (1+1) == 2          # same as assertEqual(2, 1+1)

   &#64;test(&quot;other examples&quot;)
   def _(self):
      ok (s) == 'foo'        # same as assertEqual(s, 'foo')
      ok (s) != 'foo'        # same as assertNotEqual(s, 'foo')
      ok (n) &gt; 0             # same as assertTrue(n &gt; 0)
      ok (fn).raises(Error)  # same as assertRaises(Error, fn)
      ok ([]).is_a(list)     # same as assertTrue(isinstance([], list))
      NG ([]).is_a(tuple)    # same as assertTrue(not isinstance([], tuple))
      ok ('A.txt').is_file() # same as assertTrue(os.path.isfile('A.txt'))
      NG ('A.txt').is_dir()  # same as assertTrue(not os.path.isdir('A.txt'))
</pre>
<p>Features:</p>
<ul class="simple">
<li>Provides <tt class="docutils literal">ok()</tt> which is much shorter than <tt class="docutils literal">self.assertXxxx()</tt>.</li>
<li>Allow to write test name in free text.</li>
<li><a class="reference internal" href="#fixture-injection">Fixture Injection</a> support.</li>
<li><a class="reference internal" href="#tracer">Tracer</a> class is provided which can be used as mock or stub.</li>
<li>Text diff (diff -u) is displayed when texts are different.</li>
<li>Helping WSGI application test.</li>
</ul>
<p>Oktest requires Python 2.4 or later (3.x is supported).</p>
<p>See <a href="CHANGES.txt">CHANGES.txt</a> for changes.</p>
</div>
<div class="section" id="download">

<h2><a class="toc-backref" href="#id2">Download</a></h2>
<p><a class="reference external" href="http://pypi.python.org/pypi/Oktest/">http://pypi.python.org/pypi/Oktest/</a></p>
<p>Installation:</p>
<pre class="literal-block">
## if you have installed easy_install:
$ sudo easy_install Oktest
## or download Oktest-0.15.0.tar.gz and install it
$ wget http://pypi.python.org/packages/source/O/Oktest/Oktest-0.15.0.tar.gz
$ tar xzf Oktest-0.15.0.tar.gz
$ cd Oktest-0.15.0/
$ sudo python setup.py install
</pre>
</div>
<div class="section" id="example">

<h2><a class="toc-backref" href="#id3">Example</a></h2>
<p>Oktest is available with unittest module which is a standard testing library
of Python.</p>
<pre class="literal-block">
import unittest
<strong>from oktest ok</strong>

class FooTest(unittest.TestCase):

    def test_1_plus_1_should_be_2(self):
        <strong>ok (1+1) == 2</strong>    # instead of self.assertEqual(2, 1+1)

    def test_string_should_contain_digits(self):
        <strong>ok (&quot;foo 123 bar&quot;).matches(r&quot;\d+&quot;)</strong>

if __name__ == '__main__':
    unittest.main()   # or: oktest.main()
</pre>
<p>See <a class="reference internal" href="#assertion-reference">Assertion Reference</a> section for details about <tt class="docutils literal">ok()</tt> and <tt class="docutils literal">NG()</tt>.</p>
<p>Using <tt class="docutils literal">&#64;test</tt> decorator, you can write test name in free text.</p>
<pre class="literal-block">
import unittest
from oktest ok, <strong>test</strong>

class FooTest(unittest.TestCase):

    <strong>&#64;test(&quot;1 + 1 should be 2&quot;)</strong>
    <strong>def _(self):</strong>
        ok (1+1) == 2

    <strong>&#64;test(&quot;string should contain digits&quot;)</strong>
    <strong>def _(self):</strong>
        ok (&quot;foo 123 bar&quot;).matches(r&quot;\d+&quot;)

if __name__ == '__main__':
    unittest.main()   # or: oktest.main()
</pre>
<p>See <a class="reference internal" href="#test-decorator">&#64;test Decorator</a> section for details about <tt class="docutils literal">&#64;test</tt> decorator.</p>
<p>Oktest is also available without unittest. See the folloing example.</p>
<pre class="literal-block">
import sys, os
<strong>import oktest</strong>
from oktest import ok, NG, test

## no need to extend TestCase class
class Example1Test(object):

    ## invoked only once before all tests
    &#64;classmethod
    <strong>def before_all(cls):</strong>  # or setUpClass(cls)
        os.mkdir('tmp.d')

    ## invoked only once after all tests done
    &#64;classmethod
    <strong>def after_all(cls):</strong>  # or tearDownClass(cls)
        import shutil
        shutil.rmtree('tmp.d')

    ## invoked before each test
    <strong>def before(self):</strong>   # or setUp(self)
        self.val = ['aaa', 'bbb', 'ccc']

    ## invoked after each test
    <strong>def after(self):</strong>    # or tearDown(self)
        pass

    ## test methods

    &#64;test(&quot;value should be a list&quot;)
    def _(self):
        ok (self.val).is_a(list)

    &#64;test(&quot;list length should be 3&quot;)
    def _(self):
        ok (len(self.val)) == 3

## invoke tests
if __name__ == '__main__':
    <strong>oktest.main()</strong>
    ## or
    #<strong>oktest.run(r'.*Test$')</strong>
    ## or
    #<strong>oktest.run(Example1Test, Example2Test)</strong>
</pre>
<p>Both <tt class="docutils literal">Oktest.main()</tt> and <tt class="docutils literal">Oktest.run()</tt> accept unittest.TestCase and other class.</p>
<p>How to run test script:</p>
<pre class="literal-block">
bash$ python -m oktest tests/foobar_test.py       # verbose mode
bash$ python -m oktest tests/foobar_test.py -sv   # verbose mode
bash$ python -m oktest tests/foobar_test.py -ss   # simple mode
bash$ python -m oktest tests/foobar_test.py -sp   # plain mode
bash$ python -m oktest tests    # run all test scripts (*_test.py)
</pre>
</div>
<div class="section" id="assertion-reference">

<h2><a class="toc-backref" href="#id4">Assertion Reference</a></h2>
<dl class="docutils">
<dt>ok (x) == y</dt>
<dd>Raise AssertionError unless x == y.</dd>
<dt>ok (x) != y</dt>
<dd>Raise AssertionError unless x != y.</dd>
<dt>ok (x) &gt; y</dt>
<dd>Raise AssertionError unless x &gt; y.</dd>
<dt>ok (x) &gt;= y</dt>
<dd>Raise AssertionError unless x &gt;= y.</dd>
<dt>ok (x) &lt; y</dt>
<dd>Raise AssertionError unless x &lt; y.</dd>
<dt>ok (x) &lt;= y</dt>
<dd>Raise AssertionError unless x &lt;= y.</dd>
<dt>ok (x).between(min, max)</dt>
<dd>Raise AssertionError unless min &lt;= x &lt;= max.</dd>
<dt>ok (x).in_delta(y, delta)</dt>
<dd>Raise AssertionError unless y-delta &lt; x &lt; y+delta.</dd>
<dt>ok (x).in_(y)</dt>
<dd>Raise AssertionError unless x in y.</dd>
<dt>ok (x).not_in(y)</dt>
<dd>Raise AssertionError if x in y.</dd>
<dt>ok (x).contains(y)</dt>
<dd>Raise AssertionError unless y in x. This is opposite of in_().</dd>
<dt>ok (x).not_contain(y)</dt>
<dd>Raise AssertionError if y in x. This is opposite of not_in().</dd>
<dt>ok (x).is_(y)</dt>
<dd>Raise AssertionError unless x is y.</dd>
<dt>ok (x).is_not(y)</dt>
<dd>Raise AssertionError if x is y.</dd>
<dt>ok (x).is_a(y)</dt>
<dd>Raise AssertionError unless isinstance(x, y).</dd>
<dt>ok (x).is_not_a(y)</dt>
<dd>Raise AssertionError if isinstance(x, y).</dd>
<dt>ok (x).is_truthy()</dt>
<dd>Raise AssertionError unless bool(x) == True.</dd>
<dt>ok (x).is_falsy()</dt>
<dd>Raise AssertionError unless bool(x) == False.</dd>
<dt>ok (xs).all(lambda)</dt>
<dd>Raise AssertionError unless all items in xs satisfy lambda.</dd>
<dt>ok (xs).any(lambda)</dt>
<dd>Raise AssertionError unless there is any item in xs which satisfies lambda.</dd>
<dt>ok (dict).has_key(key)</dt>
<dd>Raise AssertionError unless dict.has_key(key) or key in dict.</dd>
<dt>ok (dict).has_item(key, val)</dt>
<dd>Raise AssertionError unless dict[key] == val.</dd>
<dt>ok (x).has_attr(name)</dt>
<dd>Raise AssertionError unless hasattr(x, name).</dd>
<dt>ok (x).attr(name, value)</dt>
<dd>Raise AssertionError unless hasattr(x, name) and getattr(x, name) == value.</dd>
<dt>ok (x).matches(y[, flag=0])</dt>
<dd>If y is a string, raise AssertionError unless re.search(y, x).
If y is a re.pattern object, raise AssertionError unless y.search(x).
You can pass flag such as <tt class="docutils literal">re.M | re.S</tt>.</dd>
<dt>ok (x).not_match(y[, flag=0])</dt>
<dd>If y is a string, raise AssertionError if re.search(y, x).
If y is a re.pattern object, raise AssertionError if y.search(x).
You can pass flag such as <tt class="docutils literal">re.M | re.S</tt>.</dd>
<dt>ok (x).length(n):</dt>
<dd>Raise AssertionError unless len(x) == n.
This is same as <tt class="docutils literal">ok (len(x)) == n</tt>, but it is useful to chain
assertions, like <tt class="docutils literal">ok <span class="pre">(x).is_a(tuple).length(n)</span></tt>.</dd>
<dt>ok (x).length([min, max]):</dt>
<dd>Raise AssertionError unless min &lt;= len(x) &lt;= max.</dd>
<dt>ok (path).is_file()</dt>
<dd>Raise AssertionError unless os.path.isfile(path).</dd>
<dt>ok (path).not_file()</dt>
<dd>Raise AssertionError if os.path.isfile(path).</dd>
<dt>ok (path).is_dir()</dt>
<dd>Raise AssertionError unless os.path.isdir(path).</dd>
<dt>ok (path).not_dir()</dt>
<dd>Raise AssertionError if os.path.isdir(path).</dd>
<dt>ok (path).exists()</dt>
<dd>Raise AssertionError unless os.path.exists(path).</dd>
<dt>ok (path).not_exist()</dt>
<dd>Raise AssertionError if os.path.exists(path).</dd>
<dt>ok (func).raises(error_class[, errmsg=None])</dt>
<dd><p class="first">Raise AssertionError unless func() raises error_class.
Second argument is a string or regular expression (re.compile() object).
It sets raised exception into 'func.exception' therefore you can do another test with raised exception object.</p>
<pre class="last literal-block">
obj = &quot;foobar&quot;
def f():
    obj.name
ok (f).raises(AttributeError, &quot;'str' object has no attribute 'name'&quot;)
ok (f.exception.message) == &quot;'str' object has no attribute 'name'&quot;
</pre>
</dd>
<dt>ok (func).not_raise([error_class=Exception])</dt>
<dd>Raise AssertionError if func() raises error_class.</dd>
<dt>ok (value).should</dt>
<dd>Special property to test boolean method.
For example, <tt class="docutils literal">ok <span class="pre">(string).should.startswith('foo')</span></tt> is same as
to <tt class="docutils literal">ok <span class="pre">(string.startswith('foo'))</span> == True</tt>.</dd>
<dt>ok (value).should_not</dt>
<dd>Special property to test boolean method.
For example, <tt class="docutils literal">ok <span class="pre">(string).should_not.startswith('foo')</span></tt> is same as
to <tt class="docutils literal">ok <span class="pre">(string.startswith('foo'))</span> == False</tt>.</dd>
<dt>ok (response).is_response(status).header(name, value).body(str_or_rexp).json(dict)</dt>
<dd><p class="first">(experimental) Assertions for WebOb, Werkzeug or Requests response object.</p>
<pre class="last literal-block">
ok (response).is_response(200)                          # status code
ok (response).is_response((302, 303))                   # status code
ok (response).is_response('200 OK')                     # status line
ok (response).is_response(200, 'image/jpeg')            # content-type
ok (response).is_response(200, re.compile(r'^image/(jpeg|png|gif)$'))
ok (response).is_response(302).header(&quot;Location&quot;, &quot;/&quot;)  # header
ok (response).is_response(200).json({&quot;status&quot;: &quot;OK&quot;})   # json data
ok (response).is_response(200).body(&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;)   # response body
ok (response).is_response(200).body(re.compile(&quot;&lt;h1&gt;.*?&lt;/h1&gt;&quot;))
ok (response).is_response(200).cookie('name', 'value')  # cookie
ok (response).is_response(200).cookie('name', re.compile(r'^value$'),
                                      domain='www.example.com',
                                      path='/cgi'
                                      expires='Wed, 01-Jan-2020 12:34:56 GMT',
                                      max_age='1200',
                                      secure=True,
                                      httponly=True)
</pre>
</dd>
<dt>NG (x)</dt>
<dd><p class="first">Opposite of ok(x). For example, 'NG (&quot;foo&quot;).matches(r&quot;[0-9]+&quot;)' is True.</p>
<pre class="last literal-block">
fname = 'file.txt'
open(fname, 'w').write('foo')
ok (fname).is_file()            # file exists
os.unlink(fname)
NG (fname).is_file()        # file doesn't exist
</pre>
</dd>
<dt>not_ok (x)</dt>
<dd>Same as NG(x). Provided for backward compatibility.</dd>
<dt>NOT (x)</dt>
<dd>Same as NG(x). Provided experimentalily.</dd>
<dt>fail(message)</dt>
<dd>Raises AssertionError with message.</dd>
</dl>
<p>It is possible to chain assertions.</p>
<pre class="literal-block">
## chain assertion methods
ok (func()).is_a(tuple).length(2)
d = datetime.date(2000, 12, 31)
ok (d).attr('year', 2000).attr('month', 12).attr('day', 31)
</pre>
<p>Oktest allows you to define custom assertion functions.
See next section.</p>
</div>
<div class="section" id="custom-assertion">

<h2><a class="toc-backref" href="#id5">Custom Assertion</a></h2>
<p>You can define your own custom assertion function.</p>
<p>Simple example:</p>
<pre class="literal-block">
## define custom assertion function
import oktest
<strong>&#64;oktest.assertion</strong>
def startswith(self, arg):
    boolean = <strong>self.target</strong>.startswith(arg)
    if boolean != <strong>self.boolean</strong>:
        <strong>self.failed</strong>(&quot;%r.startswith(%r) : failed.&quot; % (self.target, arg))
    return self

## how to use
from oktest import ok
ok (&quot;Sasaki&quot;).startswith(&quot;Sas&quot;)
</pre>
<p>More complex example:</p>
<pre class="literal-block">
## define custom assertion function
import re
import oktest
<strong>&#64;oktest.assertion</strong>
def json(self, jdict):
    if self.boolean != True:
        raise TypeError(&quot;json() is not available with NOT() nor NG().&quot;)
    # response object
    response = <strong>self.target</strong>
    # assert content-type
    rexp = re.compile(r'^application/json(; ?charset=(utf|UTF)-?8)?$')
    if not rexp.match(response.content_type):
        <strong>self.failed</strong>(&quot;Unepected content-type.\n&quot;
                    &quot;  actual: %r&quot; % (response.content_type,))
    # assert response body
    import json
    actual_jdict = json.loads(response.text)
    if actual_jdict != jdict:
        <strong>self.failed</strong>(&quot;Unexpected JSON data.\n&quot;
                    &quot;  expected: %r\n&quot;
                    &quot;  actual:   %r&quot; % (jdict, actual_jdict))
    #
    return self

## how to use
from webob.response import Response
response = Response()
response.content_type = &quot;application/json&quot;
response.text = u'''{&quot;status&quot;: &quot;OK&quot;}'''
#
from oktest import ok
ok (response).json({'status': 'ok'})
</pre>
<p>(Notice that Oktest.py already provides <tt class="docutils literal"><span class="pre">ok().is_response().json(jdict)</span></tt>.)</p>
</div>
<div class="section" id="test-decorator">

<h2><a class="toc-backref" href="#id6"><tt class="docutils literal">&#64;test</tt> Decorator</a></h2>
<p>Oktest provides <tt class="docutils literal">&#64;test()</tt> decorator.
It is simple but very powerful.</p>
<p>Using <tt class="docutils literal">&#64;test()</tt> decorator, you can write test description in free text instead
of test method:</p>
<pre class="literal-block">
import unittest
<strong>from oktest import test</strong>

class FooTest(unittest.TestCase):

    def test_1_plus_1_should_be_2(self):  # not cool...
        assert 1+1 == 2

    <strong>&#64;test(&quot;1 + 1 should be 2&quot;)</strong>    # cool! easy to read &amp; write!
    <strong>def _(self):</strong>
        assert 1+1 == 2
</pre>
<p><tt class="docutils literal">&#64;test()</tt> decorator changes test methods.
For example, the above code is same as the following:</p>
<pre class="literal-block">
class FooTest(unittest.TestCase):
    __n = 0

    def _(self):
        assert 1+1 == 2

    __n += 1
    _.__doc__  = &quot;1 + 1 should be 2&quot;
    _.__name__ = &quot;test_%03d: %s&quot; % (__n, _.__doc__)
    locals()[_.__name__] = _
</pre>
<p>Non-English language is available on <tt class="docutils literal">&#64;test()</tt>:</p>
<pre class="literal-block">
class FooTest(unittest.TestCase):

    <strong>&#64;test(&quot;1 + 1 は 2 になること。&quot;)</strong>
    def _(self):
        assert 1+1 == 2
</pre>
<p><tt class="docutils literal">&#64;test()</tt> decorator accepts user-defined options. You can specify any
name and value as options, and access to them by <tt class="docutils literal">options_of(self)</tt>
in both <tt class="docutils literal">setUp()</tt> and test method.</p>
<pre class="literal-block">
import unittest
from oktest import ok, test, <strong>options_of</strong>

class FooTest(unittest.TestCase):

    def setUp(self):
        ## change setUp() behaviour according to tag
        dictionary = <strong>options_of(self)</strong>
        if dictionary.get('tag') == &quot;experimental&quot;:
            ....

    &#64;test(&quot;example&quot;, <strong>tag=&quot;experimental&quot;, num=123</strong>)
    def _(self):
        assert <strong>options_of(self)</strong> == {'tag': &quot;experimental&quot;, 'num': 123}
</pre>
<p>You can filter testcase by user-defined options in command-line.</p>
<pre class="literal-block">
## do test only tagged as 'experimental'
$ python -m oktest.py <strong>-f tag=experimental</strong> test/*_test.py
</pre>
</div>
<div class="section" id="fixture-injection">

<h2><a class="toc-backref" href="#id7">Fixture Injection</a></h2>
<p><tt class="docutils literal">&#64;test()</tt> decorator supports fixture injection.</p>
<ul class="simple">
<li>Arguments of test method are regarded as fixture names
and they are injected by <tt class="docutils literal">&#64;test()</tt> decorator automatically.</li>
<li>Instance methods or global functions which name is <tt class="docutils literal">provide_xxxx()</tt> are
regarded as fixture provider (or builder) for fixture <tt class="docutils literal">xxxx</tt>.</li>
<li>Similar to that, instance methods or global functions which name is
<tt class="docutils literal">release_xxxx()</tt> are regarded as fixture releaser (or destroyer).
Notice that provider is mandatory but releaser is optional for fixture.</li>
</ul>
<pre class="literal-block">
class SosTest(unittest.TestCase):

    ##
    ## fixture providers
    ##
    def <strong>provide_member1</strong>(self):
        return {&quot;name&quot;: &quot;Haruhi&quot;}

    def <strong>provide_member2</strong>(self):
        return {&quot;name&quot;: &quot;Kyon&quot;}

    ##
    ## fixture releasers (optional)
    ##
    def <strong>release_member1</strong>(self, value):
        assert value == {&quot;name&quot;: &quot;Haruhi&quot;}

    ##
    ## testcase which requires 'member1' and 'member2' fixtures.
    ##
    &#64;test(&quot;validate member's names&quot;)
    def _(self, <strong>member1, member2</strong>):
        ok (member1[&quot;name&quot;]) == &quot;Haruhi&quot;
        ok (member2[&quot;name&quot;]) == &quot;Kyon&quot;
</pre>
<p>This feature is more flexible and useful than <tt class="docutils literal">setUp()</tt> and <tt class="docutils literal">tearDown()</tt>.</p>
<p>For example, the following code ensures that dummy files are removed
automatically at the end of test without <tt class="docutils literal">tearDown()</tt>.</p>
<pre class="literal-block">
import os, shutil

def <strong>provide_cleaner()</strong>:
    paths = []
    return paths

def <strong>release_cleaner(paths)</strong>:
    assert isinstance(paths, list)
    ## remove dummy files registered
    for path in paths:
        if os.path.isfile(path):
            os.unlink(path)
        elif os.path.isdir(path):
            shutil.rmtree(path)

class FooTest(unittest.TestCase):

    &#64;test(&quot;example1&quot;)
    def _(self, <strong>cleaner</strong>):
        fpath = &quot;dummy.txt&quot;
        ## register dummy file
        <strong>cleaner.append(fpath)</strong>
        ## create dummy file and do test with it
        f = open(fpath, &quot;w&quot;); f.write(&quot;DUUUMY&quot;); f.close()
        ok (fpath).is_file()
</pre>
<p>Default parameter values of test methods are passed into provider functions
if necessary. Using this, you can change provider behaviour as you need.</p>
<pre class="literal-block">
## provider can have default value of argument
def provide_tempfile(<strong>content=&quot;dummy&quot;</strong>):
    filename = '__tmp.txt'
    with open(filename, 'w') as f:
        f.write(content)
    return filename

def release_tempfile(filename):
    if os.path.exists(filename):
        os.unlink(filename)

class FooTest(unittest.TestCase):

    ## override default value of providers by test method's
    ## default argument value
    &#64;test(&quot;example&quot;)
    def _(self, tempfile, <strong>content=&quot;AAAA&quot;</strong>):
        with open(tempfile) as f:
            s = f.read()
        ok (s) == <strong>&quot;AAAA&quot;</strong>

    ## if you don't specify default value in test method,
    ## provider's default value is used
    &#64;test(&quot;example&quot;)
    def _(self, tempfile):
        with open(tempfile) as f:
            s = f.read()
        ok (s) == <strong>&quot;dummy&quot;</strong>
</pre>
<p>Dependencies between fixtures are resolved automatically.
If you know dependency injection framework such as <a class="reference external" href="http://www.springsource.org/">Spring</a> or <a class="reference external" href="http://code.google.com/p/google-guice/">Guice</a>,
imagine to apply dependency injection into fixtures.</p>
<pre class="literal-block">
class BarTest(unittest.TestCase):

    ##
    ## for example:
    ## - Fixture 'a' depends on 'b' and 'c'.
    ## - Fixture 'c' depends on 'd'.
    ##
    def provide_<strong>a</strong>(<strong>b</strong>, <strong>c</strong>):  return b + c + [&quot;A&quot;]
    def provide_<strong>b</strong>():      return [&quot;B&quot;]
    def provide_<strong>c</strong>(<strong>d</strong>):     return d + [&quot;C&quot;]
    def provide_<strong>d</strong>():      reutrn [&quot;D&quot;]

    ##
    ## Dependencies between fixtures are solved automatically.
    ## If loop exists in dependency then &#64;test reports error.
    ##
    &#64;test(&quot;dependency test&quot;)
    def _(self, <strong>a</strong>):
        assert a == [&quot;B&quot;, &quot;D&quot;, &quot;C&quot;, &quot;A&quot;]
</pre>
<p>Fixture injection is provided by <tt class="docutils literal">&#64;test()</tt> decorator, and it is available
with existing test methods:</p>
<pre class="literal-block">
<strong>&#64;test()</strong>
def test_sample1(self, <strong>member1, member2</strong>):
    &quot;&quot;&quot;description&quot;&quot;&quot;
    ...
</pre>
<p>If you want to integrate with other fixture library, create manager object
and set it into <tt class="docutils literal">oktest.fixture_manager</tt>.
The following is an example to use <a class="reference external" href="https://github.com/mnoble/forge/">Forge</a> as external fixture library:</p>
<pre class="literal-block">
## fixture data
from forge import Forge
Forge.define('haruhi', name='Haruhi')
Forge.define('mikuru', name='Mikuru')
Forge.define('yuki',   name='Yuki')

## manager class
class ForgeFixtureManager(object):
    <strong>def provide(self, name):</strong>
        return Forge.build(name)
    <strong>def release(self, name, value):</strong>
        pass

## use it
<strong>oktest.fixture_manager =</strong> ForgeFixtureManager()
</pre>
</div>
<div class="section" id="at-end-decorator">

<h2><a class="toc-backref" href="#id8"><tt class="docutils literal">&#64;at_end</tt> Decorator</a></h2>
<p><tt class="docutils literal">&#64;at_end</tt> decorator registers callback function which is called at end of test case.
You can use it as replacement of <tt class="docutils literal">tearDown()</tt> or <tt class="docutils literal">after()</tt>.</p>
<pre class="literal-block">
import unittest
from oktest import ok, test, <strong>at_end</strong>

class FooTest(unittest.TestCase):
    &#64;test(&quot;file.read() returns content of file.&quot;)
    def _(self):
        # create a dummy file
        filename = &quot;dummy.tmp&quot;
        with open(filename, 'w') as f:
            f.write(&quot;homhom&quot;)
        # register callback which is invoked at end of test case
        <strong>&#64;at_end</strong>
        <strong>def _():</strong>
            <strong>import os</strong>
            <strong>os.unlink(filename)  # remove dummy file</strong>
        # do assertion
        with open(filename) as f:
            content = f.read()
        ok (content) == &quot;homhom&quot;

#
if __name__ == &quot;__main__&quot;:
    import oktest
    oktest.main()    # NOT unittest.main() !
</pre>
<p>Notice tha you must call <tt class="docutils literal">oktest.main()</tt> instead of <tt class="docutils literal">unitetst.main</tt>
to use <tt class="docutils literal">&#64;at_end</tt> decorator.</p>
<p>It is good idea to use <tt class="docutils literal">&#64;at_end</tt> instead of <tt class="docutils literal">release_xxx()</tt> methods.</p>
<pre class="literal-block">
import unittest
from oktest import ok, test, <strong>at_end</strong>

class FooTest(unittest.TestCase):

    _CONTENT = &quot;homhom&quot;

    def <strong>provide_dummyfile</strong>(self):
        # create dummy file
        filename = &quot;dummy.tmp&quot;
        with open(filename, 'w') as f:
            f.write(self._CONTENT)
        # register callback which is invoked at end of test case
        <strong>&#64;at_end</strong>
        <strong>def _():</strong>
            <strong>import os</strong>
            <strong>os.unlink(filename)  # remove dummy file</strong>
        #
        return filename

    &#64;test(&quot;file.read() returns content of file.&quot;)
    def _(self, <strong>dummyfile</strong>):
        # do assertion
        with open(dummyfile) as f:
            content = f.read()
        ok (content) == self._CONTENT

if __name__ == '__main__':
    import oktest
    oktest.main()   # NOT unittest.main() !
</pre>
<p><tt class="docutils literal">&#64;at_end</tt> decorator is similar to <tt class="docutils literal">unittest.TestCase#atCleanup()</tt>,
but the former is called <em>before</em> <tt class="docutils literal">tearDown()</tt> and the latter is called
<em>after</em> <tt class="docutils literal">tearDown()</tt>.
See the following example.:</p>
<pre class="literal-block">
import sys, unittest
from oktest import ok, test, at_end

class HomTest(unittest.TestCase):

    def <strong>tearDown</strong>(self):
        print(<strong>'** tearDown'</strong>)

    def test_ex1(self):
        <strong>&#64;self.addCleanup</strong>
        def _(): print(<strong>'** addCleanup: #1'</strong>)
        #
        <strong>&#64;at_end</strong>
        def _(): print(<strong>'** at_end: #1'</strong>)
        #
        <strong>&#64;self.addCleanup</strong>
        def _(): print(<strong>'** addCleanup: #2'</strong>)
        #
        <strong>&#64;at_end</strong>
        def _(): print(<strong>'** at_end: #2'</strong>)
        #
        assert 1+1 == 2

if __name__ == &quot;__main__&quot;:
    import oktest
    oktest.main()
</pre>
<p>Result:</p>
<pre class="literal-block">
$ py hom_test.py
* HomTest
  - [      ] test_ex1<strong>** at_end: #2</strong>
<strong>** at_end: #1</strong>
<strong>** tearDown</strong>
<strong>** addCleanup: #2</strong>
<strong>** addCleanup: #1</strong>
  - [pass] test_ex1
## total:1, pass:1, fail:0, error:0, skip:0, todo:0  (0.001 sec)
</pre>
</div>
<div class="section" id="test-context">

<h2><a class="toc-backref" href="#id9">Test Context</a></h2>
<p><strong>(Experimental)</strong></p>
<p>Oktest provides helper functions to describe test methods in structural style.</p>
<pre class="literal-block">
from oktest import ok, test
<strong>from oktest import subject, situation</strong>

class SampleTestCase(unittest.TestCase):
    <strong>SUBJECT = &quot;Sample&quot;</strong>

    <strong>with subject(&quot;method1()&quot;):</strong>

        <strong>with situation(&quot;when condition:&quot;):</strong>

            &#64;test(&quot;spec1&quot;)
            def _(self):
              ...

            &#64;test(&quot;spec2&quot;)
            def _(self):
              ...

        <strong>with situation(&quot;else:&quot;):</strong>

            &#64;test(&quot;spec3&quot;)
            def _(self):
                ...
</pre>
<p>Output example:</p>
<pre class="literal-block">
* Sample
  + method1()
    + when condition:
      - [pass] spec1
      - [pass] spec2
    + else:
      - [pass] spec3
## total:3, pass:3, fail:0, error:0, skip:0, todo:0  (0.000 sec)
</pre>
<p>(Notice that this feature is experimental and may be changed in the future.)</p>
</div>
<div class="section" id="unified-diff">

<h2><a class="toc-backref" href="#id10">Unified Diff</a></h2>
<p>'ok(x) == y' prints unified diff (diff -u) if:</p>
<ul class="simple">
<li>both x and y are one of str, unicode, list, tuple, and dict</li>
<li>and x != y</li>
<li>and <tt class="docutils literal">oktest.DIFF</tt> is True or 'repr'</li>
<li>and invoked with <tt class="docutils literal">oktest.main()</tt> or <tt class="docutils literal">oktest.run()</tt></li>
</ul>
<p>For example:</p>
<pre class="literal-block">
## foo_test.py
import unittest
from oktest import ok

class FooTest(unittest.TestCase):

    def test1(self):
        s1 = ( &quot;AAA\n&quot;
               &quot;BBB\n&quot;
               &quot;CCC\n&quot; )
        s2 = ( &quot;AAA\n&quot;
               &quot;CCC\n&quot;
               &quot;DDD\n&quot; )
        ok (s1) == s2

if __name__ == '__main__':
    unittest.main()
</pre>
<p>If you run this script, you'll find that unified diff is displayed.</p>
<p>Output result:</p>
<pre class="literal-block">
$ python -V
Python 2.5.5
$ python foo_test.py
F
======================================================================
FAIL: test1 (__main__.FooTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;foo_test.py&quot;, line 14, in test1
    ok (s1) == s2
AssertionError: 'AAA\nBBB\nCCC\n' == 'AAA\nCCC\nDDD\n' : failed.
--- expected
+++ actual
&#64;&#64; -1,3 +1,3 &#64;&#64;
 AAA
+BBB
 CCC
-DDD


----------------------------------------------------------------------
Ran 1 test in 0.006s

FAILED (failures=1)
</pre>
<p>When actual and expected values are list, tuple or dict, then <tt class="docutils literal">ok()</tt> converts
these values into string by <tt class="docutils literal">pprint.pformat()</tt> before calculating unified
diff output. For example:</p>
<pre class="literal-block">
## json_test.py
import unittest
from oktest import ok

class JsonTest(unittest.TestCase):
    def test_ex1(self):
        expected = { 'username': &quot;Haruhi&quot;, 'gender': &quot;Female&quot;,
                     'email': &quot;haruhi&#64;sos-brigade.org&quot;, }
        actual   = { 'username': &quot;Haruhi&quot;, 'gender': &quot;female&quot;,
                     'email': &quot;haruhi&#64;sos-brigade.org&quot;, }
        ok (actual) == expected
#
if __name__ == &quot;__main__&quot;:
    unittest.main()
</pre>
<p>Result shows in unified diff format using <tt class="docutils literal">pprint.pformat()</tt>:</p>
<pre class="literal-block">
$ py json_test.py
F
======================================================================
FAIL: test_ex1 (__main__.JsonTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;json_test.py&quot;, line 11, in test_ex1
    ok (actual) == expected
AssertionError: {'username': 'Haruhi', 'gender': 'female', 'email': 'haruhi&#64;sos
-brigade.org'} == {'username': 'Haruhi', 'gender': 'Female', 'email': 'haruhi&#64;s
os-brigade.org'} : failed.
--- expected
+++ actual
&#64;&#64; -1,3 +1,3 &#64;&#64;
 {'email': 'haruhi&#64;sos-brigade.org',
- 'gender': 'Female',
+ 'gender': 'female',
  'username': 'Haruhi'}
\ No newline at end of string


----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
</pre>
<p>If you set <tt class="docutils literal">oktest.DIFF</tt> to <tt class="docutils literal">repr</tt>, each line is preprocessed by <tt class="docutils literal">repr()</tt>.
This is very useful to show non-visible characters. For example:</p>
<pre class="literal-block">
## foo_test.py
import unittest
from oktest import ok
import oktest
<strong>oktest.DIFF = repr</strong>

class FooTest(unittest.TestCase):

    def test1(self):
        s1 = ( &quot;AAA\n&quot;
               <strong>&quot;BBB  \n&quot;</strong>     # contains white space character
               &quot;CCC\n&quot; )
        s2 = ( &quot;AAA\n&quot;
               <strong>&quot;BBB\n&quot;</strong>
               &quot;CCC\n&quot; )
        ok (s1) == s2

if __name__ == '__main__':
    unittest.main()
</pre>
<p>Result:</p>
<pre class="literal-block">
$ python foo_test.py
F
======================================================================
FAIL: test1 (__main__.FooTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;foo_test.py&quot;, line 16, in test1
    ok (s1) == s2
AssertionError: 'AAA\nBBB \nCCC\n' == 'AAA\nBBB\nCCC\n' : failed.
--- expected
+++ actual
&#64;&#64; -1,3 +1,3 &#64;&#64;
 'AAA\n'
<strong>+'BBB  \n'</strong>
<strong>-'BBB\n'</strong>
 'CCC\n'


----------------------------------------------------------------------
Ran 1 test in 0.011s

FAILED (failures=1)
</pre>
<p>If you set <tt class="docutils literal">oktest.DIFF</tt> to False, unified diff is not displayed.</p>
</div>
<div class="section" id="testing-wsgi-application">

<h2><a class="toc-backref" href="#id11">Testing WSGI Application</a></h2>
<p>Oktest.py provides testing helpers for WSGI Application.</p>
<dl class="docutils">
<dt>oktest.web.WSGITest</dt>
<dd>simpulates HTTP request for WSGI application.</dd>
</dl>
<p>Example:</p>
<pre class="literal-block">
## create WSGI application
class App(object):
    def __call__(self, environ, start_response):
        status  = '200 OK'
        headers = [('Content-Type', 'application/json')]
        body    = [b'''{&quot;message&quot;:&quot;Hello!&quot;}''']  # bytes, not unicode
        start_response(status, headers)
        return body

app = App()

## test for app
import unittest
import oktest
from oktest import test, ok, subject
<strong>from oktest.web import WSGITest</strong>

<strong>http  = WSGITest(app)</strong>
<strong>https = WSGITest(app, {'HTTPS': 'on'})</strong>

class AppTest(unittest.TestCase):

    with subject('GET /'):

        &#64;test(&quot;Returns JSON containing message.&quot;)
        def _(self):
            <strong>resp = http.GET('/')</strong>     # or http('GET', '/')
            ok (resp).is_response(200).json({&quot;message&quot;: &quot;Hello!&quot;})
            ## or
            <strong>status, headers, body = http.GET('/')</strong>
            ok (status)  == '200 OK'
            ok (headers) == [('Content-Type', 'application/json')]
            ok (body)    == [b'''{&quot;message&quot;:&quot;Hello!&quot;}''']

if __name__ == '__main__':
    oktest.main()
</pre>
<p>It is possible to pass query string, form parameter, or JSON body by
<tt class="docutils literal">form</tt>, <tt class="docutils literal">query</tt>, or <tt class="docutils literal">json</tt> keyword argument respectively.</p>
<pre class="literal-block">
http.GET('/', <strong>query</strong>={'offset':&quot;0&quot;, 'limit':&quot;30&quot;})  # dict
http.GET('/', <strong>query</strong>=&quot;offset=0&amp;limit=30&quot;)           # str
http.GET('/', <strong>form</strong>={'offset':&quot;0&quot;, 'limit':&quot;30&quot;})   # dict
http.GET('/', <strong>form</strong>=&quot;offset=0&amp;limit=30&quot;)            # str
http.GET('/', <strong>json</strong>={'offset':&quot;0&quot;, 'limit':&quot;30&quot;})   # dict
http.GET('/', <strong>json</strong>='''{&quot;offset&quot;:0,&quot;limit&quot;:30}''')  # str
</pre>
<p><tt class="docutils literal">params</tt> is recognized as <tt class="docutils literal">query</tt> (for GET or HEAD) or <tt class="docutils literal">query</tt>
(for POST, PUT, DELETE, or PATCH).</p>
<pre class="literal-block">
http.GET('/', <strong>params</strong>={'x':'1'})   # same as http.GET('/', query={'x':'1'})
http.POST('/', <strong>params</strong>={'x':'1'})  # same as http.POST('/', form={'x':'1'})
</pre>
<p>Possible to specify HTTP headers and cookies:</p>
<pre class="literal-block">
http.GET('/', <strong>headers</strong>={'Cookie': 'name=val'})
http.GET('/', <strong>cookies</strong>='name=val')   # or {'name':'val'}
</pre>
<p>And also possible to specify environ dict.</p>
<pre class="literal-block">
environ = {
    'HTTPS': 'on',                     # simulates https
    'HTTP_USER_AGENT': 'Mozilla/5.0',  # simulates browser
}

## specify on WSGITest
http = WSGITest(app, <strong>environ</strong>)

## or on http.GET(), http.POST(), ...
response = http.GET('/', <strong>environ=environ</strong>)
</pre>
<p>Since release 0.15, Oktest.py provides <tt class="docutils literal">oktest.web.MultiPart</tt> class
which builds multipart form data.</p>
<pre class="literal-block">
from oktest.web import MultiPart
mp = MultiPart()    # or boundary='abcdef'; mp = MutliPart(boundary)
print(mp.boundary)
    #=&gt; 0dC42pwi4FJs4czr-zMTPjCCDPJEZ_acT
print(mp.content_type)
    #=&gt; multipart/form-data; boundary=0dC42pwi4FJs4czr-zMTPjCCDPJEZ_acT

mp.add(&quot;name1&quot;, &quot;value1&quot;)          # add string value
with open(&quot;logo.png&quot;, 'wb') as f:  # add file value
    mp.add(&quot;file1&quot;, f.read(), &quot;logo.png&quot;, &quot;image/png&quot;)
print(mp.build())
</pre>
<p>How to test with multipart form data:</p>
<pre class="literal-block">
resp = http.POST('/upload', <strong>multipart=mp</strong>)
## or
resp = http.POST('/upload', <strong>params=mp</strong>)
</pre>
</div>
<div class="section" id="validator">

<h2><a class="toc-backref" href="#id12">Validator</a></h2>
<p><strong>(Experimental)</strong></p>
<p><tt class="docutils literal">oktest.validator.Validator</tt> is very useful to test
complicated data structure such as JSON.</p>
<p>Example:</p>
<pre class="literal-block">
<strong>from oktest.validator import Validator as V</strong>

ok (json_data) == {
    &quot;status&quot;: &quot;OK&quot;,
    &quot;member&quot;: {
        &quot;id&quot;:       1,
        &quot;name&quot;:     &quot;Haruhi&quot;,
        &quot;gender&quot;:   <strong>V('gender', enum=('M', 'F'))</strong>,
        &quot;age&quot;:      <strong>V('age', type=int)</strong>,
        &quot;birthday&quot;: <strong>V('birthday', pattern=r'^\d\d\d\d-\d\d-\d\d$')</strong>,
    }
}
</pre>
<p>Usage:</p>
<pre class="literal-block">
## Raises AssertionError when actual data failed to validation.
actual == Validator(name, type=type, enum=enum, between=between,
                    length=length, pattern=pattern, func=func)
</pre>
<p>Parameters:</p>
<dl class="docutils">
<dt>name:</dt>
<dd>Arbitrary name to distinguish others on assertion error.</dd>
<dt>type:</dt>
<dd><p class="first">Type such as int, float, str, and so on.
ex:</p>
<pre class="last literal-block">
Validator(name, type=int)
Validator(name, type=(int, long, float))
</pre>
</dd>
<dt>enum:</dt>
<dd><p class="first">Expected values of that actual value should be member.
ex:</p>
<pre class="last literal-block">
Validator(name, enum=('jpg', 'png', 'gif'))
</pre>
</dd>
<dt>between:</dt>
<dd><p class="first">Tuple of min and max value.
ex:</p>
<pre class="last literal-block">
Validator(name, between(0, 100))
</pre>
</dd>
<dt>length:</dt>
<dd><p class="first">Int of length, or tuple of min and max length.
ex:</p>
<pre class="last literal-block">
Validator(name, 255)
Validator(name, (1, 255))
</pre>
</dd>
<dt>pattern:</dt>
<dd><p class="first">Regular expression string or pattern object or tuple of pattern and option
ex:</p>
<pre class="last literal-block">
Validator(name, r'^[a-f0-9]+$')
Validator(name, (r'^[a-f0-9]+$', re.I))
Validator(name, re.compile(r'^[a-f0-9]+$', re.I))
</pre>
</dd>
<dt>func:</dt>
<dd><p class="first">Callback function which returns error message when validation failed.
ex:</p>
<pre class="last literal-block">
Validator(name, func=lambda actual: \
    &quot;Even number expected&quot; if actual % 2 != 0 else None)
</pre>
</dd>
</dl>
<p>It is possible to add your own validator options. See source code for details.</p>
</div>
<div class="section" id="tracer">

<h2><a class="toc-backref" href="#id13">Tracer</a></h2>
<p>Oktest provides <tt class="docutils literal">Tracer</tt> class which can be stub or mock object.
<tt class="docutils literal">Tracer</tt> class can:</p>
<ul class="simple">
<li>Create fake object.</li>
<li>Trace method or function call.</li>
<li>Fake method, or function.</li>
</ul>
<p>In any case, <tt class="docutils literal">Tracer</tt> object records both arguments and return-value of method or function calls.</p>
<p>Example to create fake object:</p>
<pre class="literal-block">
## create fake objects
<strong>from oktest.tracer import Tracer</strong>
<strong>tr = Tracer()</strong>
foo = <strong>tr.fake_obj(m1=100, m2=200)</strong>   # method name and return-value
bar = <strong>tr.fake_obj(m3=lambda self, x: x+1)</strong>  # method name and body
## call fake methods
ok (bar.m3(0))     == 1
ok (foo.m2(1,2,3)) == 200    # any argument can be passed
ok (foo.m1(x=123)) == 100    # any argument can be passed
## check results
ok (repr(<strong>tr[0]</strong>))   == 'm3(0) #=&gt; 1'
ok (repr(<strong>tr[1]</strong>))   == 'm2(1, 2, 3) #=&gt; 200'
ok (repr(<strong>tr[2]</strong>))   == 'm1(x=123) #=&gt; 100'
</pre>
<p>There are several ways to check results:</p>
<pre class="literal-block">
from oktest.tracer import Tracer
tr = Tracer()
obj = tr.fake_obj(meth=9)
ok (obj.meth(1, 2, x=3)) == 9
## check results
ok (<strong>repr(tr[0])</strong>)  == 'meth(1, 2, x=3) #=&gt; 9'
## or
ok (<strong>tr[0].list()</strong>) == [obj, 'meth', (1, 2), {'x': 3}, 9]
## or
ok (<strong>tr[0]</strong>)        == [obj, 'meth', (1, 2), {'x': 3}, 9]
## or
ok (<strong>tr[0].receiver</strong>).is_(obj)
ok (<strong>tr[0].name</strong>)   == 'meth'
ok (<strong>tr[0].args</strong>)   == (1, 2)
ok (<strong>tr[0].kwargs</strong>) == {'x': 3}
ok (<strong>tr[0].ret</strong>)    == 9
</pre>
<p>Example to trace method call:</p>
<pre class="literal-block">
class Foo(object):
    def add(self, x, y):
        return x + y
    def hello(self, name='World'):
        return &quot;Hello &quot; + name
obj = Foo()
## trace methods
from oktest.tracer import Tracer
tr = Tracer()
<strong>tr.trace_method(obj, 'add', 'hello')</strong>
## call methods
ok (obj.add(2, 3)) == 5
ok (obj.hello(name=&quot;SOS&quot;)) == &quot;Hello SOS&quot;
## check results
ok (tr[0]) == [obj, 'add', (2, 3), {}, 5]
ok (tr[1]) == [obj, 'hello', (), {'name':'SOS'}, &quot;Hello SOS&quot;]
</pre>
<p>Example to trace function call:</p>
<pre class="literal-block">
def f(x):
    return x+1
def g(y):
    return f(y+1) + 1
## trace functions
from oktest.tracer import Tracer
tr = Tracer()
<strong>f = tr.trace_func(f)</strong>
<strong>g = tr.trace_func(g)</strong>
## call functions
ok (g(0)) == 3
## check results
ok (tr[0]) == [None, 'g', (0,), {}, 3]
ok (tr[1]) == [None, 'f', (1,), {}, 2]
</pre>
<p>Example to fake method call:</p>
<pre class="literal-block">
class Foo(object):
    def add(self, x, y):
        return x + y
    def hello(self, name='World'):
        return &quot;Hello &quot; + name
obj = Foo()
## fake methods
from oktest.tracer import Tracer
tr = Tracer()
def dummy(original_func, *args, **kwargs):
    return &quot;Hello!&quot;
<strong>tr.fake_method(obj, add=100, hello=dummy)</strong>
## call methods
ok (obj.add(2, 3)) == 100
ok (obj.hello(name=&quot;SOS&quot;)) == &quot;Hello!&quot;
## check results
ok (tr[0]) == [obj, 'add', (2, 3), {}, 100]
ok (tr[1]) == [obj, 'hello', (), {'name':&quot;SOS&quot;}, &quot;Hello!&quot;]
</pre>
<p>Example to fake function call:</p>
<pre class="literal-block">
def f(x):
    return x*2
## fake a function
def dummy(original_func, x):
    return 'x=%s' % repr(x)
from oktest.tracer import Tracer
tr = Tracer()
<strong>f = tr.fake_func(f, dummy)</strong>
## call function
ok (f(3))  == 'x=3'
## check results
ok (tr[0]) == [None, 'f', (3,), {}, 'x=3']
</pre>
</div>
<div class="section" id="skip-test">

<h2><a class="toc-backref" href="#id14">Skip Test</a></h2>
<p><strong>(Experimental)</strong></p>
<p>It is possible to skip tests according to a certain condition.</p>
<pre class="literal-block">
import unittest
import oktest
from oktest import ok, test, <strong>skip</strong>
some_condition = True

class SkipExampleTest(unittest.TestCase):

    &#64;test(&quot;example of skip&quot;)
    def _(self):
        if some_condition:
            <strong>skip(&quot;reason to skip&quot;)</strong>
        ...

    &#64;test(&quot;example of skip&quot;)
    <strong>&#64;skip.when(some_condition, &quot;reason to skip&quot;)</strong>
    def _(self):
        ...

    ## unittest2 helpers are also available (if you installed it)
    &#64;unittest.skipIf(some_condition, &quot;reason to skip&quot;)
    def testExample(self):
        ...

if __name__ == '__main__':
    oktest.main()
</pre>
<p>Notice that the following doesn't work correctly.</p>
<pre class="literal-block">
## NG: &#64;skip.when should be the below of &#64;test
&#64;skip.when(some_condition, &quot;reason to skip&quot;)
&#64;test(&quot;example of skip&quot;)
def _(self):
    ...
</pre>
</div>
<div class="section" id="todo-decorator">

<h2><a class="toc-backref" href="#id15"><tt class="docutils literal">&#64;todo</tt> Decorator</a></h2>
<p><tt class="docutils literal">&#64;todo</tt> decorator represents that &quot;this test will be failed expectedly
because feature is not implemented yet, therefore don't count
this test as failed, please!&quot;.</p>
<p>Code Example:</p>
<pre class="literal-block">
import unittest
from oktest import ok, test, <strong>todo</strong>

def add(x, y):
    return 0    ## not implemented yet!

class AddTest(unittest.TestCase):
    SUBJECT = 'add()'

    &#64;test(&quot;returns sum of arguments.&quot;)
    <strong>&#64;todo</strong>      # equivarent to &#64;unittest.expectedFailure
    def _(self):
        n = add(10, 20)
        ok (n) == 30    # will be failed expectedly
                        # (because add() is not implemented yet)

if __name__ == '__main__':
    import oktest
    oktest.main()
</pre>
<p>Output Example:</p>
<pre class="literal-block">
$ python test/add_test.py
* add()
  - [TODO] returns sum of arguments.
## total:1, pass:0, fail:0, error:0, skip:0, todo:1  (0.000 sec)
</pre>
<p>If test decoreated by <tt class="docutils literal">&#64;todo</tt> doesn't raise AssertionError, Oktest will report
you that, for example:</p>
<pre class="literal-block">
$ python test/add_test.py
* add()
  - [Fail] returns sum of arguments.
----------------------------------------------------------------------
[Fail] add() &gt; 001: returns sum of arguments.
_UnexpectedSuccess: test should be failed (because not implemented yet), but passed unexpectedly.
----------------------------------------------------------------------
## total:1, pass:0, fail:1, error:0, skip:0, todo:0  (0.000 sec)
</pre>
<p>Notice that the following will not work:</p>
<pre class="literal-block">
## NG: &#64;todo should be appeared after &#64;test decorator
&#64;todo
&#64;test(&quot;....&quot;)
def _(self): ...
</pre>
</div>
<div class="section" id="command-line-interface">

<h2><a class="toc-backref" href="#id16">Command-line Interface</a></h2>
<p>Oktest now supports command-line interface to execute test scripts.</p>
<pre class="literal-block">
## run test scripts except foo_*.py
$ python -m oktest <strong>-x 'foo_*.py' tests/*_test.py</strong>
## run test scripts in 'tests' dir with pattern '*_test.py'
$ python -m oktest <strong>-p '*_test.py' tests</strong>
## reports result in plain format (p: plain, s: simple, v: verbose)
$ python -m oktest <strong>-sp</strong> tests
## filter by class name
$ python -m oktest <strong>-f class='ClassName*'</strong> tests
## filter by test method name
$ python -m oktest <strong>-f test='*keyword*'</strong> tests   # or <strong>-f '*keyword*'</strong>
## filter by user-defined option added by &#64;test decorator
$ python -m oktest <strong>-f tag='*value*'</strong> tests
</pre>
<p>Try <tt class="docutils literal">python <span class="pre">-m</span> oktest <span class="pre">-h</span></tt> for details about command-line options.</p>
<p>If you use <tt class="docutils literal">oktest.main()</tt> in your test script, it accepts command-line options.</p>
<pre class="literal-block">
## reports output in plain format
$ python test/foobar_test.py <strong>-sp -f test='*keyword*'</strong>
</pre>
</div>
<div class="section" id="helpers-reference">

<h2><a class="toc-backref" href="#id17">Helpers Reference</a></h2>
<div class="section" id="oktest-module">

<h3><a class="toc-backref" href="#id18"><tt class="docutils literal">oktest</tt> module</a></h3>
<dl class="docutils">
<dt>fail(message)</dt>
<dd>Raises AssertionError exception with message.</dd>
<dt>main(*args)</dt>
<dd><p class="first">Invokes tests of each class.
Args represents command-line options.</p>
<pre class="last literal-block">
import oktest
oktest.main()         # same as: python -m oktest
oktest.main('-sp')    # same as: python -m oktest -sp
</pre>
</dd>
<dt>NG(actual)</dt>
<dd>Represents test assertion.
See <a class="reference internal" href="#assertion-reference">Assertion Reference</a> section.</dd>
<dt>ok(actual)</dt>
<dd>Represents test assertion.
See <a class="reference internal" href="#assertion-reference">Assertion Reference</a> section.</dd>
<dt>run(*classes)</dt>
<dd><p class="first">Invokes tests of each class.
Argument can be regular expression string.</p>
<pre class="last literal-block">
import oktest
oktest.run(FooTest, BarTest)  # invokes FooTest and BarTest
oktest.run(r'.*Test$')        # invokes FooTest, BarTest, and so on
oktest.run()                  # same as oktest.run('.*(Test|TestCase|_TC)$')
</pre>
</dd>
<dt>subject(name)</dt>
<dd>Represents subject of specs such as ClassName, method_name() or feature name.
See <a class="reference internal" href="#test-context">Test Context</a> section.</dd>
<dt>situation(desc)</dt>
<dd>Represents situation of specs such as a certain condition.
See <a class="reference internal" href="#test-context">Test Context</a> section.</dd>
<dt>spec(description)</dt>
<dd><p class="first"><del>(Obsolete! Don't use this!)</del>
NOT OBSOLETED</p>
<p>Represents spec description.
This is just a marker function, but very useful for readability.</p>
<pre class="last literal-block">
class NumericTest(object):
    def test_integer(self):
        with spec(&quot;1+1 should be equal to 2.&quot;):
            ok (1+1) == 2
        with spec(&quot;1/0 should be error.&quot;):
            def f(): 1/0
            ok (f).raises(ZeroDivisionError,
                          &quot;integer division or modulo by zero&quot;)
        ## spec() is also available as decorator
        &#64;spec(&quot;1+1 should be equal to 2.&quot;)
        def _():
            ok (1+1) == 2
        ## tips: 'for' statement is available instead of 'with' for Python 2.4
        for _ in spec(&quot;1+1 should be equal to 2.&quot;):
            ok (1+1) == 2
</pre>
</dd>
<dt>skip(reason)</dt>
<dd>Skip test method.
Equivarent to <tt class="docutils literal">unittest.skip()</tt> or <tt class="docutils literal">unittest.skipIf()</tt>.
See <a class="reference internal" href="#skip-test">Skip Test</a> section.</dd>
<dt>test(desc)</dt>
<dd>Decorator to generate test method with spec description.
See <a class="reference internal" href="#test-decorator">&#64;test Decorator</a> section.</dd>
<dt>todo()</dt>
<dd>Represents that the test will be failed expectedly.
Equivarent to <tt class="docutils literal">unittest.expectedFailure()</tt>.
See <a class="reference internal" href="#todo-decorator">&#64;todo Decorator</a> section.</dd>
</dl>
</div>
<div class="section" id="oktest-util-module">

<h3><a class="toc-backref" href="#id19"><tt class="docutils literal">oktest.util</tt> module</a></h3>
<p>Since 0.10.0, <tt class="docutils literal">oktest.helper</tt> is renamed to <tt class="docutils literal">oktest.util</tt>, but
<tt class="docutils literal">oktest.helper</tt> is still available for backward compatibility.</p>
<dl class="docutils">
<dt>chdir(dirname)</dt>
<dd><p class="first">Change current directory to dirname temporarily.</p>
<pre class="last literal-block">
import os
from oktest.util import chdir
cwd = os.getcwd()                         # current working directory
with chdir(&quot;/var/tmp&quot;):
    assert os.getcwd() == &quot;/var/tmp&quot;      # current directory is changed!
    # do something
assert os.getcwd() == cwd                 # back to the original place
## or
&#64;chdir(&quot;/var/tmp&quot;)
def fn():
    assert os.getcwd() == &quot;/var/tmp&quot;
    # do something
</pre>
</dd>
<dt>rm_rf(filename, dirname, ...)</dt>
<dd>Remove file or directory recursively.</dd>
<dt>from_here(dirpath=None)</dt>
<dd><p class="first">Set current directory as the first element of sys.path temporarily.
This is useful very much when you want to import a certain module
from current directory or a specific directory.</p>
<pre class="last literal-block">
from oktest.util import from_here
with from_here():
  import mymodule1       # import from directory path of this file
with from_here('../lib'):
  import mymodule2       # import from ../lib
</pre>
</dd>
<dt>randstr(n=8)</dt>
<dd><p class="first">Return random number string which width is n (default 8).
This is useful when creating fixture data.</p>
<pre class="last literal-block">
&gt;&gt;&gt; from oktest.util import randstr
&gt;&gt;&gt; randstr(4)
'7327'
&gt;&gt;&gt; randstr(4)
'1598'
&gt;&gt;&gt; randstr(4)
'0362'
&gt;&gt;&gt; randstr()
'38127841'
</pre>
</dd>
</dl>
</div>
<div class="section" id="oktest-dummy-module">

<h3><a class="toc-backref" href="#id20"><tt class="docutils literal">oktest.dummy</tt> module</a></h3>
<dl class="docutils">
<dt>dummy_file(filename, content)</dt>
<dd><p class="first">Create dummy file with specified content.</p>
<pre class="last literal-block">
import os
from oktest.helper import dummy_file
assert not os.path.exists(&quot;A.txt&quot;)        # file doesn't exist
with dummy_file(&quot;A.txt&quot;, &quot;aaa&quot;):
    assert os.path.isfile(&quot;A.txt&quot;)        # file is created!
    # do something
assert not os.path.exists(&quot;A.txt&quot;)        # file is removed
## or
&#64;dummy_file(&quot;A.txt&quot;, &quot;aaa&quot;)
def fn():
    assert os.path.isfile(&quot;A.txt&quot;)
</pre>
</dd>
<dt>dummy_dir(dirname)</dt>
<dd><p class="first">Create dummy directory.</p>
<pre class="last literal-block">
import os
from oktest.helper import dummy_dir
assert not os.path.exists(&quot;tmpdir&quot;)       # directory doesn't exist
with dummy_dir(&quot;tmpdir&quot;):
    assert os.path.isdir(&quot;tmpdir&quot;)        # directory is created!
    # do something
assert not os.path.exists(&quot;tmpdir&quot;)       # directory is removed
## or
&#64;dummy_dir(&quot;tmpdir&quot;)
def fn():
    assert os.path.isdir(&quot;tmpdir&quot;)
</pre>
</dd>
<dt>dummy_values(dictionary, items_=None, **kwargs):</dt>
<dd><p class="first">Change dictionary's values temporarily.</p>
<pre class="last literal-block">
from oktest.helper import dummy_values
d = {'A':10, 'B':20}
with dummy_values(d, A=1000, X=2000):
    assert d['A'] == 1000                 # dictionary values are changed!
    assert d['B'] == 20
    assert d['X'] == 2000
    # do something
assert d == {'A':10, 'B':20}              # values are backed
## or
&#64;dummy_values(d, A=1000, X=2000)
def fn():
    assert d['A'] == 1000
</pre>
</dd>
<dt>dummy_attrs(object, items_=None, **kwargs):</dt>
<dd><p class="first">Change object's attributes temporarily.
This is same as dummy_values(object.__dict__, **kwargs).</p>
<pre class="last literal-block">
from oktest.helper import dummy_attrs
class Hello(object):
    pass
obj = Hello()
obj.x = 10
obj.y = 20
with dummy_attrs(obj, x=90, z=100):
    assert obj.x == 90                    # attributes are changed!
    assert obj.y == 20
    assert obj.z == 100
    # do something
assert obj.x == 10                        # attributes are backed
assert obj.y == 20
assert not hasattr(obj, 'z')
## or
&#64;dummy_attrs(obj, x=90, z=100)
def fn():
    assert obj.x == 90
</pre>
</dd>
<dt>dummy_io(stdin_content=None, func=None):</dt>
<dd><p class="first">Set dummy I/O to sys.stdout, sys.stderr, and sys.stdin.</p>
<pre class="last literal-block">
with dummy_io(&quot;SOS&quot;) as d_io:
    assert sys.stdin.read() == &quot;SOS&quot;
    print(&quot;Haruhi&quot;)
sout, serr = d_io
assert sout == &quot;Haruhi\n&quot;
assert serr == &quot;&quot;
## or
&#64;dummy_io(&quot;SOS&quot;)
def d_io():
    assert sys.stdin.read() == &quot;SOS&quot;
    print(&quot;Haruhi&quot;)
sout, serr = d_io
assert sout == &quot;Haruhi\n&quot;
assert serr == &quot;&quot;
</pre>
</dd>
</dl>
</div>
<div class="section" id="oktest-tracer-module">

<h3><a class="toc-backref" href="#id21"><tt class="docutils literal">oktest.tracer</tt> module</a></h3>
<dl class="docutils">
<dt>Tracer:</dt>
<dd>Tracer class. See <a class="reference internal" href="#tracer">Tracer</a> section for details.</dd>
</dl>
</div>
<div class="section" id="oktest-web-module">

<h3><a class="toc-backref" href="#id22"><tt class="docutils literal">oktest.web</tt> module</a></h3>
<dl class="docutils">
<dt>WSGITest:</dt>
<dd>Helper class to simulate http request for WSGI Application.
See <a class="reference internal" href="#testing-wsgi-application">Testing WSGI Application</a> section for details.</dd>
</dl>
</div>
</div>
<div class="section" id="tips">

<h2><a class="toc-backref" href="#id23">Tips</a></h2>
<ul>
<li><p class="first">It is possible to chain assertion methods.</p>
<pre class="literal-block">
## chain assertion methods
ok (func()).is_a(tuple).length(2)
d = datetime.date(2000, 12, 31)
ok (d).attr('year', 2000).attr('month', 12).attr('day', 31)
</pre>
</li>
<li><p class="first"><tt class="docutils literal">oktest.run()</tt> returns total number of failures and errors.</p>
<pre class="literal-block">
## exit with status code 0 when no errors.
sys.exit(run())
</pre>
</li>
<li><p class="first">If you call <tt class="docutils literal">ok()</tt> or <tt class="docutils literal">NG()</tt> but forget to do assertion, oktest warns it.</p>
<pre class="literal-block">
import oktest
from oktest import ok, NG

class FooTest(object):
    def test_1(self):
        #ok (1+1) == 2
        ok (1+1)         # missing assertion

oktest.main()   #=&gt; warning: ok() is called but not tested.
</pre>
</li>
<li><p class="first">It is possible to embed spec id into test description with '[!xxxxx]' format.</p>
<pre class="literal-block">
## python
class HomhomTest(unittest.TestCase):
    &#64;test('[!bk201] 1+1 should be 2')    # spec id is 'bk201'
    def _(self):
        ok (1+1) == 2
    &#64;test('[!nov11] 1-1 should be 0')    # spec id is 'nov11'
    def _(self):
        ok (1-1) == 0
</pre>
<p>You can filter tests by spec id (sid).</p>
<blockquote>
<p>## filter by spec id
$ python -m oktest test/example_test.py -f sid=bk201</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal">$TEST</tt> environment variable is now obsolete.
Use command-line option instead to filter testcase by name.</p>
<pre class="literal-block">
## filter testcase by name
$ python -m oktest -f test='*foobar*' test/foo_test.py
</pre>
</li>
</ul>
</div>
<div class="section" id="license">

<h2><a class="toc-backref" href="#id24">License</a></h2>
<p>$License: MIT License $</p>
</div>
<div class="section" id="copyright">

<h2><a class="toc-backref" href="#id25">Copyright</a></h2>
<p>$Copyright: copyright(c) 2010-2014 kuwata-lab.com all rights reserved $</p>
</div>
</div>
</body>
</html>
